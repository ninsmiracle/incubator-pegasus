/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef partition_split_TYPES_H
#define partition_split_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "dsn_types.h"
#include "dsn.layer2_types.h"
#include "metadata_types.h"


namespace dsn { namespace replication {

struct split_control_type {
  enum type {
    PAUSE = 0,
    RESTART = 1,
    CANCEL = 2
  };
};

extern const std::map<int, const char*> _split_control_type_VALUES_TO_NAMES;

class start_partition_split_request;

class start_partition_split_response;

class control_split_request;

class control_split_response;

class query_split_request;

class query_split_response;

class notify_catch_up_request;

class notify_cacth_up_response;

class update_child_group_partition_count_request;

class update_child_group_partition_count_response;

class register_child_request;

class register_child_response;

class notify_stop_split_request;

class notify_stop_split_response;

class query_child_state_request;

class query_child_state_response;

typedef struct _start_partition_split_request__isset {
  _start_partition_split_request__isset() : app_name(false), new_partition_count(false) {}
  bool app_name :1;
  bool new_partition_count :1;
} _start_partition_split_request__isset;

class start_partition_split_request {
 public:

  start_partition_split_request(const start_partition_split_request&);
  start_partition_split_request& operator=(const start_partition_split_request&);
  start_partition_split_request() : app_name(), new_partition_count(0) {
  }

  virtual ~start_partition_split_request() throw();
  std::string app_name;
  int32_t new_partition_count;

  _start_partition_split_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_new_partition_count(const int32_t val);

  bool operator == (const start_partition_split_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(new_partition_count == rhs.new_partition_count))
      return false;
    return true;
  }
  bool operator != (const start_partition_split_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const start_partition_split_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(start_partition_split_request &a, start_partition_split_request &b);

inline std::ostream& operator<<(std::ostream& out, const start_partition_split_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _start_partition_split_response__isset {
  _start_partition_split_response__isset() : err(false), hint_msg(false) {}
  bool err :1;
  bool hint_msg :1;
} _start_partition_split_response__isset;

class start_partition_split_response {
 public:

  start_partition_split_response(const start_partition_split_response&);
  start_partition_split_response& operator=(const start_partition_split_response&);
  start_partition_split_response() : hint_msg() {
  }

  virtual ~start_partition_split_response() throw();
   ::dsn::error_code err;
  std::string hint_msg;

  _start_partition_split_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_hint_msg(const std::string& val);

  bool operator == (const start_partition_split_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(hint_msg == rhs.hint_msg))
      return false;
    return true;
  }
  bool operator != (const start_partition_split_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const start_partition_split_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(start_partition_split_response &a, start_partition_split_response &b);

inline std::ostream& operator<<(std::ostream& out, const start_partition_split_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _control_split_request__isset {
  _control_split_request__isset() : app_name(false), control_type(false), parent_pidx(false), old_partition_count(false) {}
  bool app_name :1;
  bool control_type :1;
  bool parent_pidx :1;
  bool old_partition_count :1;
} _control_split_request__isset;

class control_split_request {
 public:

  control_split_request(const control_split_request&);
  control_split_request& operator=(const control_split_request&);
  control_split_request() : app_name(), control_type((split_control_type::type)0), parent_pidx(0), old_partition_count(0) {
  }

  virtual ~control_split_request() throw();
  std::string app_name;
  split_control_type::type control_type;
  int32_t parent_pidx;
  int32_t old_partition_count;

  _control_split_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_control_type(const split_control_type::type val);

  void __set_parent_pidx(const int32_t val);

  void __set_old_partition_count(const int32_t val);

  bool operator == (const control_split_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(control_type == rhs.control_type))
      return false;
    if (!(parent_pidx == rhs.parent_pidx))
      return false;
    if (__isset.old_partition_count != rhs.__isset.old_partition_count)
      return false;
    else if (__isset.old_partition_count && !(old_partition_count == rhs.old_partition_count))
      return false;
    return true;
  }
  bool operator != (const control_split_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const control_split_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(control_split_request &a, control_split_request &b);

inline std::ostream& operator<<(std::ostream& out, const control_split_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _control_split_response__isset {
  _control_split_response__isset() : err(false), hint_msg(false) {}
  bool err :1;
  bool hint_msg :1;
} _control_split_response__isset;

class control_split_response {
 public:

  control_split_response(const control_split_response&);
  control_split_response& operator=(const control_split_response&);
  control_split_response() : hint_msg() {
  }

  virtual ~control_split_response() throw();
   ::dsn::error_code err;
  std::string hint_msg;

  _control_split_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_hint_msg(const std::string& val);

  bool operator == (const control_split_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (__isset.hint_msg != rhs.__isset.hint_msg)
      return false;
    else if (__isset.hint_msg && !(hint_msg == rhs.hint_msg))
      return false;
    return true;
  }
  bool operator != (const control_split_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const control_split_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(control_split_response &a, control_split_response &b);

inline std::ostream& operator<<(std::ostream& out, const control_split_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_split_request__isset {
  _query_split_request__isset() : app_name(false) {}
  bool app_name :1;
} _query_split_request__isset;

class query_split_request {
 public:

  query_split_request(const query_split_request&);
  query_split_request& operator=(const query_split_request&);
  query_split_request() : app_name() {
  }

  virtual ~query_split_request() throw();
  std::string app_name;

  _query_split_request__isset __isset;

  void __set_app_name(const std::string& val);

  bool operator == (const query_split_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    return true;
  }
  bool operator != (const query_split_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_split_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_split_request &a, query_split_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_split_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_split_response__isset {
  _query_split_response__isset() : err(false), new_partition_count(false), status(false), hint_msg(false) {}
  bool err :1;
  bool new_partition_count :1;
  bool status :1;
  bool hint_msg :1;
} _query_split_response__isset;

class query_split_response {
 public:

  query_split_response(const query_split_response&);
  query_split_response& operator=(const query_split_response&);
  query_split_response() : new_partition_count(0), hint_msg() {
  }

  virtual ~query_split_response() throw();
   ::dsn::error_code err;
  int32_t new_partition_count;
  std::map<int32_t,  ::dsn::replication::split_status::type>  status;
  std::string hint_msg;

  _query_split_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_new_partition_count(const int32_t val);

  void __set_status(const std::map<int32_t,  ::dsn::replication::split_status::type> & val);

  void __set_hint_msg(const std::string& val);

  bool operator == (const query_split_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(new_partition_count == rhs.new_partition_count))
      return false;
    if (!(status == rhs.status))
      return false;
    if (__isset.hint_msg != rhs.__isset.hint_msg)
      return false;
    else if (__isset.hint_msg && !(hint_msg == rhs.hint_msg))
      return false;
    return true;
  }
  bool operator != (const query_split_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_split_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_split_response &a, query_split_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_split_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _notify_catch_up_request__isset {
  _notify_catch_up_request__isset() : parent_gpid(false), child_gpid(false), child_ballot(false), child_address(false) {}
  bool parent_gpid :1;
  bool child_gpid :1;
  bool child_ballot :1;
  bool child_address :1;
} _notify_catch_up_request__isset;

class notify_catch_up_request {
 public:

  notify_catch_up_request(const notify_catch_up_request&);
  notify_catch_up_request& operator=(const notify_catch_up_request&);
  notify_catch_up_request() : child_ballot(0) {
  }

  virtual ~notify_catch_up_request() throw();
   ::dsn::gpid parent_gpid;
   ::dsn::gpid child_gpid;
  int64_t child_ballot;
   ::dsn::rpc_address child_address;

  _notify_catch_up_request__isset __isset;

  void __set_parent_gpid(const  ::dsn::gpid& val);

  void __set_child_gpid(const  ::dsn::gpid& val);

  void __set_child_ballot(const int64_t val);

  void __set_child_address(const  ::dsn::rpc_address& val);

  bool operator == (const notify_catch_up_request & rhs) const
  {
    if (!(parent_gpid == rhs.parent_gpid))
      return false;
    if (!(child_gpid == rhs.child_gpid))
      return false;
    if (!(child_ballot == rhs.child_ballot))
      return false;
    if (!(child_address == rhs.child_address))
      return false;
    return true;
  }
  bool operator != (const notify_catch_up_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const notify_catch_up_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(notify_catch_up_request &a, notify_catch_up_request &b);

inline std::ostream& operator<<(std::ostream& out, const notify_catch_up_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _notify_cacth_up_response__isset {
  _notify_cacth_up_response__isset() : err(false) {}
  bool err :1;
} _notify_cacth_up_response__isset;

class notify_cacth_up_response {
 public:

  notify_cacth_up_response(const notify_cacth_up_response&);
  notify_cacth_up_response& operator=(const notify_cacth_up_response&);
  notify_cacth_up_response() {
  }

  virtual ~notify_cacth_up_response() throw();
   ::dsn::error_code err;

  _notify_cacth_up_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const notify_cacth_up_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const notify_cacth_up_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const notify_cacth_up_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(notify_cacth_up_response &a, notify_cacth_up_response &b);

inline std::ostream& operator<<(std::ostream& out, const notify_cacth_up_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _update_child_group_partition_count_request__isset {
  _update_child_group_partition_count_request__isset() : target_address(false), new_partition_count(false), child_pid(false), ballot(false) {}
  bool target_address :1;
  bool new_partition_count :1;
  bool child_pid :1;
  bool ballot :1;
} _update_child_group_partition_count_request__isset;

class update_child_group_partition_count_request {
 public:

  update_child_group_partition_count_request(const update_child_group_partition_count_request&);
  update_child_group_partition_count_request& operator=(const update_child_group_partition_count_request&);
  update_child_group_partition_count_request() : new_partition_count(0), ballot(0) {
  }

  virtual ~update_child_group_partition_count_request() throw();
   ::dsn::rpc_address target_address;
  int32_t new_partition_count;
   ::dsn::gpid child_pid;
  int64_t ballot;

  _update_child_group_partition_count_request__isset __isset;

  void __set_target_address(const  ::dsn::rpc_address& val);

  void __set_new_partition_count(const int32_t val);

  void __set_child_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  bool operator == (const update_child_group_partition_count_request & rhs) const
  {
    if (!(target_address == rhs.target_address))
      return false;
    if (!(new_partition_count == rhs.new_partition_count))
      return false;
    if (!(child_pid == rhs.child_pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    return true;
  }
  bool operator != (const update_child_group_partition_count_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const update_child_group_partition_count_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(update_child_group_partition_count_request &a, update_child_group_partition_count_request &b);

inline std::ostream& operator<<(std::ostream& out, const update_child_group_partition_count_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _update_child_group_partition_count_response__isset {
  _update_child_group_partition_count_response__isset() : err(false) {}
  bool err :1;
} _update_child_group_partition_count_response__isset;

class update_child_group_partition_count_response {
 public:

  update_child_group_partition_count_response(const update_child_group_partition_count_response&);
  update_child_group_partition_count_response& operator=(const update_child_group_partition_count_response&);
  update_child_group_partition_count_response() {
  }

  virtual ~update_child_group_partition_count_response() throw();
   ::dsn::error_code err;

  _update_child_group_partition_count_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const update_child_group_partition_count_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const update_child_group_partition_count_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const update_child_group_partition_count_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(update_child_group_partition_count_response &a, update_child_group_partition_count_response &b);

inline std::ostream& operator<<(std::ostream& out, const update_child_group_partition_count_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _register_child_request__isset {
  _register_child_request__isset() : app(false), parent_config(false), child_config(false), primary_address(false) {}
  bool app :1;
  bool parent_config :1;
  bool child_config :1;
  bool primary_address :1;
} _register_child_request__isset;

class register_child_request {
 public:

  register_child_request(const register_child_request&);
  register_child_request& operator=(const register_child_request&);
  register_child_request() {
  }

  virtual ~register_child_request() throw();
   ::dsn::app_info app;
   ::dsn::partition_configuration parent_config;
   ::dsn::partition_configuration child_config;
   ::dsn::rpc_address primary_address;

  _register_child_request__isset __isset;

  void __set_app(const  ::dsn::app_info& val);

  void __set_parent_config(const  ::dsn::partition_configuration& val);

  void __set_child_config(const  ::dsn::partition_configuration& val);

  void __set_primary_address(const  ::dsn::rpc_address& val);

  bool operator == (const register_child_request & rhs) const
  {
    if (!(app == rhs.app))
      return false;
    if (!(parent_config == rhs.parent_config))
      return false;
    if (!(child_config == rhs.child_config))
      return false;
    if (!(primary_address == rhs.primary_address))
      return false;
    return true;
  }
  bool operator != (const register_child_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const register_child_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(register_child_request &a, register_child_request &b);

inline std::ostream& operator<<(std::ostream& out, const register_child_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _register_child_response__isset {
  _register_child_response__isset() : err(false), app(false), parent_config(false), child_config(false) {}
  bool err :1;
  bool app :1;
  bool parent_config :1;
  bool child_config :1;
} _register_child_response__isset;

class register_child_response {
 public:

  register_child_response(const register_child_response&);
  register_child_response& operator=(const register_child_response&);
  register_child_response() {
  }

  virtual ~register_child_response() throw();
   ::dsn::error_code err;
   ::dsn::app_info app;
   ::dsn::partition_configuration parent_config;
   ::dsn::partition_configuration child_config;

  _register_child_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_app(const  ::dsn::app_info& val);

  void __set_parent_config(const  ::dsn::partition_configuration& val);

  void __set_child_config(const  ::dsn::partition_configuration& val);

  bool operator == (const register_child_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(app == rhs.app))
      return false;
    if (!(parent_config == rhs.parent_config))
      return false;
    if (!(child_config == rhs.child_config))
      return false;
    return true;
  }
  bool operator != (const register_child_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const register_child_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(register_child_response &a, register_child_response &b);

inline std::ostream& operator<<(std::ostream& out, const register_child_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _notify_stop_split_request__isset {
  _notify_stop_split_request__isset() : app_name(false), parent_gpid(false), meta_split_status(false), partition_count(false) {}
  bool app_name :1;
  bool parent_gpid :1;
  bool meta_split_status :1;
  bool partition_count :1;
} _notify_stop_split_request__isset;

class notify_stop_split_request {
 public:

  notify_stop_split_request(const notify_stop_split_request&);
  notify_stop_split_request& operator=(const notify_stop_split_request&);
  notify_stop_split_request() : app_name(), meta_split_status(( ::dsn::replication::split_status::type)0), partition_count(0) {
  }

  virtual ~notify_stop_split_request() throw();
  std::string app_name;
   ::dsn::gpid parent_gpid;
   ::dsn::replication::split_status::type meta_split_status;
  int32_t partition_count;

  _notify_stop_split_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_parent_gpid(const  ::dsn::gpid& val);

  void __set_meta_split_status(const  ::dsn::replication::split_status::type val);

  void __set_partition_count(const int32_t val);

  bool operator == (const notify_stop_split_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(parent_gpid == rhs.parent_gpid))
      return false;
    if (!(meta_split_status == rhs.meta_split_status))
      return false;
    if (!(partition_count == rhs.partition_count))
      return false;
    return true;
  }
  bool operator != (const notify_stop_split_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const notify_stop_split_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(notify_stop_split_request &a, notify_stop_split_request &b);

inline std::ostream& operator<<(std::ostream& out, const notify_stop_split_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _notify_stop_split_response__isset {
  _notify_stop_split_response__isset() : err(false) {}
  bool err :1;
} _notify_stop_split_response__isset;

class notify_stop_split_response {
 public:

  notify_stop_split_response(const notify_stop_split_response&);
  notify_stop_split_response& operator=(const notify_stop_split_response&);
  notify_stop_split_response() {
  }

  virtual ~notify_stop_split_response() throw();
   ::dsn::error_code err;

  _notify_stop_split_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const notify_stop_split_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const notify_stop_split_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const notify_stop_split_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(notify_stop_split_response &a, notify_stop_split_response &b);

inline std::ostream& operator<<(std::ostream& out, const notify_stop_split_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_child_state_request__isset {
  _query_child_state_request__isset() : app_name(false), pid(false), partition_count(false) {}
  bool app_name :1;
  bool pid :1;
  bool partition_count :1;
} _query_child_state_request__isset;

class query_child_state_request {
 public:

  query_child_state_request(const query_child_state_request&);
  query_child_state_request& operator=(const query_child_state_request&);
  query_child_state_request() : app_name(), partition_count(0) {
  }

  virtual ~query_child_state_request() throw();
  std::string app_name;
   ::dsn::gpid pid;
  int32_t partition_count;

  _query_child_state_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_pid(const  ::dsn::gpid& val);

  void __set_partition_count(const int32_t val);

  bool operator == (const query_child_state_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(partition_count == rhs.partition_count))
      return false;
    return true;
  }
  bool operator != (const query_child_state_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_child_state_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_child_state_request &a, query_child_state_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_child_state_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_child_state_response__isset {
  _query_child_state_response__isset() : err(false), partition_count(false), child_config(false) {}
  bool err :1;
  bool partition_count :1;
  bool child_config :1;
} _query_child_state_response__isset;

class query_child_state_response {
 public:

  query_child_state_response(const query_child_state_response&);
  query_child_state_response& operator=(const query_child_state_response&);
  query_child_state_response() : partition_count(0) {
  }

  virtual ~query_child_state_response() throw();
   ::dsn::error_code err;
  int32_t partition_count;
   ::dsn::partition_configuration child_config;

  _query_child_state_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_partition_count(const int32_t val);

  void __set_child_config(const  ::dsn::partition_configuration& val);

  bool operator == (const query_child_state_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (__isset.partition_count != rhs.__isset.partition_count)
      return false;
    else if (__isset.partition_count && !(partition_count == rhs.partition_count))
      return false;
    if (__isset.child_config != rhs.__isset.child_config)
      return false;
    else if (__isset.child_config && !(child_config == rhs.child_config))
      return false;
    return true;
  }
  bool operator != (const query_child_state_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_child_state_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_child_state_response &a, query_child_state_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_child_state_response& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
