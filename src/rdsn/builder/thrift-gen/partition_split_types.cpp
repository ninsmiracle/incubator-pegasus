/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "partition_split_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _ksplit_control_typeValues[] = {
  split_control_type::PAUSE,
  split_control_type::RESTART,
  split_control_type::CANCEL
};
const char* _ksplit_control_typeNames[] = {
  "PAUSE",
  "RESTART",
  "CANCEL"
};
const std::map<int, const char*> _split_control_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _ksplit_control_typeValues, _ksplit_control_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


start_partition_split_request::~start_partition_split_request() throw() {
}


void start_partition_split_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void start_partition_split_request::__set_new_partition_count(const int32_t val) {
  this->new_partition_count = val;
}

uint32_t start_partition_split_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->new_partition_count);
          this->__isset.new_partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_partition_split_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_partition_split_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->new_partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_partition_split_request &a, start_partition_split_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.new_partition_count, b.new_partition_count);
  swap(a.__isset, b.__isset);
}

start_partition_split_request::start_partition_split_request(const start_partition_split_request& other0) {
  app_name = other0.app_name;
  new_partition_count = other0.new_partition_count;
  __isset = other0.__isset;
}
start_partition_split_request& start_partition_split_request::operator=(const start_partition_split_request& other1) {
  app_name = other1.app_name;
  new_partition_count = other1.new_partition_count;
  __isset = other1.__isset;
  return *this;
}
void start_partition_split_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_partition_split_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "new_partition_count=" << to_string(new_partition_count);
  out << ")";
}


start_partition_split_response::~start_partition_split_response() throw() {
}


void start_partition_split_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void start_partition_split_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
}

uint32_t start_partition_split_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_partition_split_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_partition_split_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_partition_split_response &a, start_partition_split_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

start_partition_split_response::start_partition_split_response(const start_partition_split_response& other2) {
  err = other2.err;
  hint_msg = other2.hint_msg;
  __isset = other2.__isset;
}
start_partition_split_response& start_partition_split_response::operator=(const start_partition_split_response& other3) {
  err = other3.err;
  hint_msg = other3.hint_msg;
  __isset = other3.__isset;
  return *this;
}
void start_partition_split_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_partition_split_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg=" << to_string(hint_msg);
  out << ")";
}


control_split_request::~control_split_request() throw() {
}


void control_split_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void control_split_request::__set_control_type(const split_control_type::type val) {
  this->control_type = val;
}

void control_split_request::__set_parent_pidx(const int32_t val) {
  this->parent_pidx = val;
}

void control_split_request::__set_old_partition_count(const int32_t val) {
  this->old_partition_count = val;
__isset.old_partition_count = true;
}

uint32_t control_split_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->control_type = (split_control_type::type)ecast4;
          this->__isset.control_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_pidx);
          this->__isset.parent_pidx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->old_partition_count);
          this->__isset.old_partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_split_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_split_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("control_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->control_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_pidx", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->parent_pidx);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.old_partition_count) {
    xfer += oprot->writeFieldBegin("old_partition_count", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->old_partition_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_split_request &a, control_split_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.control_type, b.control_type);
  swap(a.parent_pidx, b.parent_pidx);
  swap(a.old_partition_count, b.old_partition_count);
  swap(a.__isset, b.__isset);
}

control_split_request::control_split_request(const control_split_request& other5) {
  app_name = other5.app_name;
  control_type = other5.control_type;
  parent_pidx = other5.parent_pidx;
  old_partition_count = other5.old_partition_count;
  __isset = other5.__isset;
}
control_split_request& control_split_request::operator=(const control_split_request& other6) {
  app_name = other6.app_name;
  control_type = other6.control_type;
  parent_pidx = other6.parent_pidx;
  old_partition_count = other6.old_partition_count;
  __isset = other6.__isset;
  return *this;
}
void control_split_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_split_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "control_type=" << to_string(control_type);
  out << ", " << "parent_pidx=" << to_string(parent_pidx);
  out << ", " << "old_partition_count="; (__isset.old_partition_count ? (out << to_string(old_partition_count)) : (out << "<null>"));
  out << ")";
}


control_split_response::~control_split_response() throw() {
}


void control_split_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void control_split_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
__isset.hint_msg = true;
}

uint32_t control_split_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_split_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_split_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint_msg) {
    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_split_response &a, control_split_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

control_split_response::control_split_response(const control_split_response& other7) {
  err = other7.err;
  hint_msg = other7.hint_msg;
  __isset = other7.__isset;
}
control_split_response& control_split_response::operator=(const control_split_response& other8) {
  err = other8.err;
  hint_msg = other8.hint_msg;
  __isset = other8.__isset;
  return *this;
}
void control_split_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_split_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg="; (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
  out << ")";
}


query_split_request::~query_split_request() throw() {
}


void query_split_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t query_split_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_split_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_split_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_split_request &a, query_split_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

query_split_request::query_split_request(const query_split_request& other9) {
  app_name = other9.app_name;
  __isset = other9.__isset;
}
query_split_request& query_split_request::operator=(const query_split_request& other10) {
  app_name = other10.app_name;
  __isset = other10.__isset;
  return *this;
}
void query_split_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_split_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


query_split_response::~query_split_response() throw() {
}


void query_split_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_split_response::__set_new_partition_count(const int32_t val) {
  this->new_partition_count = val;
}

void query_split_response::__set_status(const std::map<int32_t,  ::dsn::replication::split_status::type> & val) {
  this->status = val;
}

void query_split_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
__isset.hint_msg = true;
}

uint32_t query_split_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->new_partition_count);
          this->__isset.new_partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->status.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              int32_t _key16;
              xfer += iprot->readI32(_key16);
               ::dsn::replication::split_status::type& _val17 = this->status[_key16];
              int32_t ecast18;
              xfer += iprot->readI32(ecast18);
              _val17 = ( ::dsn::replication::split_status::type)ecast18;
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_split_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_split_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->new_partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->status.size()));
    std::map<int32_t,  ::dsn::replication::split_status::type> ::const_iterator _iter19;
    for (_iter19 = this->status.begin(); _iter19 != this->status.end(); ++_iter19)
    {
      xfer += oprot->writeI32(_iter19->first);
      xfer += oprot->writeI32((int32_t)_iter19->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint_msg) {
    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_split_response &a, query_split_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.new_partition_count, b.new_partition_count);
  swap(a.status, b.status);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

query_split_response::query_split_response(const query_split_response& other20) {
  err = other20.err;
  new_partition_count = other20.new_partition_count;
  status = other20.status;
  hint_msg = other20.hint_msg;
  __isset = other20.__isset;
}
query_split_response& query_split_response::operator=(const query_split_response& other21) {
  err = other21.err;
  new_partition_count = other21.new_partition_count;
  status = other21.status;
  hint_msg = other21.hint_msg;
  __isset = other21.__isset;
  return *this;
}
void query_split_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_split_response(";
  out << "err=" << to_string(err);
  out << ", " << "new_partition_count=" << to_string(new_partition_count);
  out << ", " << "status=" << to_string(status);
  out << ", " << "hint_msg="; (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
  out << ")";
}


notify_catch_up_request::~notify_catch_up_request() throw() {
}


void notify_catch_up_request::__set_parent_gpid(const  ::dsn::gpid& val) {
  this->parent_gpid = val;
}

void notify_catch_up_request::__set_child_gpid(const  ::dsn::gpid& val) {
  this->child_gpid = val;
}

void notify_catch_up_request::__set_child_ballot(const int64_t val) {
  this->child_ballot = val;
}

void notify_catch_up_request::__set_child_address(const  ::dsn::rpc_address& val) {
  this->child_address = val;
}

uint32_t notify_catch_up_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parent_gpid.read(iprot);
          this->__isset.parent_gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_gpid.read(iprot);
          this->__isset.child_gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->child_ballot);
          this->__isset.child_ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_address.read(iprot);
          this->__isset.child_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notify_catch_up_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notify_catch_up_request");

  xfer += oprot->writeFieldBegin("parent_gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->parent_gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_gpid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->child_gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_ballot", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->child_ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_address", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->child_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notify_catch_up_request &a, notify_catch_up_request &b) {
  using ::std::swap;
  swap(a.parent_gpid, b.parent_gpid);
  swap(a.child_gpid, b.child_gpid);
  swap(a.child_ballot, b.child_ballot);
  swap(a.child_address, b.child_address);
  swap(a.__isset, b.__isset);
}

notify_catch_up_request::notify_catch_up_request(const notify_catch_up_request& other22) {
  parent_gpid = other22.parent_gpid;
  child_gpid = other22.child_gpid;
  child_ballot = other22.child_ballot;
  child_address = other22.child_address;
  __isset = other22.__isset;
}
notify_catch_up_request& notify_catch_up_request::operator=(const notify_catch_up_request& other23) {
  parent_gpid = other23.parent_gpid;
  child_gpid = other23.child_gpid;
  child_ballot = other23.child_ballot;
  child_address = other23.child_address;
  __isset = other23.__isset;
  return *this;
}
void notify_catch_up_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notify_catch_up_request(";
  out << "parent_gpid=" << to_string(parent_gpid);
  out << ", " << "child_gpid=" << to_string(child_gpid);
  out << ", " << "child_ballot=" << to_string(child_ballot);
  out << ", " << "child_address=" << to_string(child_address);
  out << ")";
}


notify_cacth_up_response::~notify_cacth_up_response() throw() {
}


void notify_cacth_up_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t notify_cacth_up_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notify_cacth_up_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notify_cacth_up_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notify_cacth_up_response &a, notify_cacth_up_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

notify_cacth_up_response::notify_cacth_up_response(const notify_cacth_up_response& other24) {
  err = other24.err;
  __isset = other24.__isset;
}
notify_cacth_up_response& notify_cacth_up_response::operator=(const notify_cacth_up_response& other25) {
  err = other25.err;
  __isset = other25.__isset;
  return *this;
}
void notify_cacth_up_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notify_cacth_up_response(";
  out << "err=" << to_string(err);
  out << ")";
}


update_child_group_partition_count_request::~update_child_group_partition_count_request() throw() {
}


void update_child_group_partition_count_request::__set_target_address(const  ::dsn::rpc_address& val) {
  this->target_address = val;
}

void update_child_group_partition_count_request::__set_new_partition_count(const int32_t val) {
  this->new_partition_count = val;
}

void update_child_group_partition_count_request::__set_child_pid(const  ::dsn::gpid& val) {
  this->child_pid = val;
}

void update_child_group_partition_count_request::__set_ballot(const int64_t val) {
  this->ballot = val;
}

uint32_t update_child_group_partition_count_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target_address.read(iprot);
          this->__isset.target_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->new_partition_count);
          this->__isset.new_partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_pid.read(iprot);
          this->__isset.child_pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t update_child_group_partition_count_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("update_child_group_partition_count_request");

  xfer += oprot->writeFieldBegin("target_address", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->target_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_partition_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->new_partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_pid", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->child_pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(update_child_group_partition_count_request &a, update_child_group_partition_count_request &b) {
  using ::std::swap;
  swap(a.target_address, b.target_address);
  swap(a.new_partition_count, b.new_partition_count);
  swap(a.child_pid, b.child_pid);
  swap(a.ballot, b.ballot);
  swap(a.__isset, b.__isset);
}

update_child_group_partition_count_request::update_child_group_partition_count_request(const update_child_group_partition_count_request& other26) {
  target_address = other26.target_address;
  new_partition_count = other26.new_partition_count;
  child_pid = other26.child_pid;
  ballot = other26.ballot;
  __isset = other26.__isset;
}
update_child_group_partition_count_request& update_child_group_partition_count_request::operator=(const update_child_group_partition_count_request& other27) {
  target_address = other27.target_address;
  new_partition_count = other27.new_partition_count;
  child_pid = other27.child_pid;
  ballot = other27.ballot;
  __isset = other27.__isset;
  return *this;
}
void update_child_group_partition_count_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "update_child_group_partition_count_request(";
  out << "target_address=" << to_string(target_address);
  out << ", " << "new_partition_count=" << to_string(new_partition_count);
  out << ", " << "child_pid=" << to_string(child_pid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ")";
}


update_child_group_partition_count_response::~update_child_group_partition_count_response() throw() {
}


void update_child_group_partition_count_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t update_child_group_partition_count_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t update_child_group_partition_count_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("update_child_group_partition_count_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(update_child_group_partition_count_response &a, update_child_group_partition_count_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

update_child_group_partition_count_response::update_child_group_partition_count_response(const update_child_group_partition_count_response& other28) {
  err = other28.err;
  __isset = other28.__isset;
}
update_child_group_partition_count_response& update_child_group_partition_count_response::operator=(const update_child_group_partition_count_response& other29) {
  err = other29.err;
  __isset = other29.__isset;
  return *this;
}
void update_child_group_partition_count_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "update_child_group_partition_count_response(";
  out << "err=" << to_string(err);
  out << ")";
}


register_child_request::~register_child_request() throw() {
}


void register_child_request::__set_app(const  ::dsn::app_info& val) {
  this->app = val;
}

void register_child_request::__set_parent_config(const  ::dsn::partition_configuration& val) {
  this->parent_config = val;
}

void register_child_request::__set_child_config(const  ::dsn::partition_configuration& val) {
  this->child_config = val;
}

void register_child_request::__set_primary_address(const  ::dsn::rpc_address& val) {
  this->primary_address = val;
}

uint32_t register_child_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app.read(iprot);
          this->__isset.app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parent_config.read(iprot);
          this->__isset.parent_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_config.read(iprot);
          this->__isset.child_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primary_address.read(iprot);
          this->__isset.primary_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_child_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_child_request");

  xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->app.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->parent_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_config", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->child_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary_address", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->primary_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_child_request &a, register_child_request &b) {
  using ::std::swap;
  swap(a.app, b.app);
  swap(a.parent_config, b.parent_config);
  swap(a.child_config, b.child_config);
  swap(a.primary_address, b.primary_address);
  swap(a.__isset, b.__isset);
}

register_child_request::register_child_request(const register_child_request& other30) {
  app = other30.app;
  parent_config = other30.parent_config;
  child_config = other30.child_config;
  primary_address = other30.primary_address;
  __isset = other30.__isset;
}
register_child_request& register_child_request::operator=(const register_child_request& other31) {
  app = other31.app;
  parent_config = other31.parent_config;
  child_config = other31.child_config;
  primary_address = other31.primary_address;
  __isset = other31.__isset;
  return *this;
}
void register_child_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_child_request(";
  out << "app=" << to_string(app);
  out << ", " << "parent_config=" << to_string(parent_config);
  out << ", " << "child_config=" << to_string(child_config);
  out << ", " << "primary_address=" << to_string(primary_address);
  out << ")";
}


register_child_response::~register_child_response() throw() {
}


void register_child_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void register_child_response::__set_app(const  ::dsn::app_info& val) {
  this->app = val;
}

void register_child_response::__set_parent_config(const  ::dsn::partition_configuration& val) {
  this->parent_config = val;
}

void register_child_response::__set_child_config(const  ::dsn::partition_configuration& val) {
  this->child_config = val;
}

uint32_t register_child_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app.read(iprot);
          this->__isset.app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parent_config.read(iprot);
          this->__isset.parent_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_config.read(iprot);
          this->__isset.child_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_child_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_child_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->app.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_config", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parent_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("child_config", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->child_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_child_response &a, register_child_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.app, b.app);
  swap(a.parent_config, b.parent_config);
  swap(a.child_config, b.child_config);
  swap(a.__isset, b.__isset);
}

register_child_response::register_child_response(const register_child_response& other32) {
  err = other32.err;
  app = other32.app;
  parent_config = other32.parent_config;
  child_config = other32.child_config;
  __isset = other32.__isset;
}
register_child_response& register_child_response::operator=(const register_child_response& other33) {
  err = other33.err;
  app = other33.app;
  parent_config = other33.parent_config;
  child_config = other33.child_config;
  __isset = other33.__isset;
  return *this;
}
void register_child_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_child_response(";
  out << "err=" << to_string(err);
  out << ", " << "app=" << to_string(app);
  out << ", " << "parent_config=" << to_string(parent_config);
  out << ", " << "child_config=" << to_string(child_config);
  out << ")";
}


notify_stop_split_request::~notify_stop_split_request() throw() {
}


void notify_stop_split_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void notify_stop_split_request::__set_parent_gpid(const  ::dsn::gpid& val) {
  this->parent_gpid = val;
}

void notify_stop_split_request::__set_meta_split_status(const  ::dsn::replication::split_status::type val) {
  this->meta_split_status = val;
}

void notify_stop_split_request::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

uint32_t notify_stop_split_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parent_gpid.read(iprot);
          this->__isset.parent_gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->meta_split_status = ( ::dsn::replication::split_status::type)ecast34;
          this->__isset.meta_split_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notify_stop_split_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notify_stop_split_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_gpid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->parent_gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->meta_split_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notify_stop_split_request &a, notify_stop_split_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.parent_gpid, b.parent_gpid);
  swap(a.meta_split_status, b.meta_split_status);
  swap(a.partition_count, b.partition_count);
  swap(a.__isset, b.__isset);
}

notify_stop_split_request::notify_stop_split_request(const notify_stop_split_request& other35) {
  app_name = other35.app_name;
  parent_gpid = other35.parent_gpid;
  meta_split_status = other35.meta_split_status;
  partition_count = other35.partition_count;
  __isset = other35.__isset;
}
notify_stop_split_request& notify_stop_split_request::operator=(const notify_stop_split_request& other36) {
  app_name = other36.app_name;
  parent_gpid = other36.parent_gpid;
  meta_split_status = other36.meta_split_status;
  partition_count = other36.partition_count;
  __isset = other36.__isset;
  return *this;
}
void notify_stop_split_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notify_stop_split_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "parent_gpid=" << to_string(parent_gpid);
  out << ", " << "meta_split_status=" << to_string(meta_split_status);
  out << ", " << "partition_count=" << to_string(partition_count);
  out << ")";
}


notify_stop_split_response::~notify_stop_split_response() throw() {
}


void notify_stop_split_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t notify_stop_split_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notify_stop_split_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notify_stop_split_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notify_stop_split_response &a, notify_stop_split_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

notify_stop_split_response::notify_stop_split_response(const notify_stop_split_response& other37) {
  err = other37.err;
  __isset = other37.__isset;
}
notify_stop_split_response& notify_stop_split_response::operator=(const notify_stop_split_response& other38) {
  err = other38.err;
  __isset = other38.__isset;
  return *this;
}
void notify_stop_split_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notify_stop_split_response(";
  out << "err=" << to_string(err);
  out << ")";
}


query_child_state_request::~query_child_state_request() throw() {
}


void query_child_state_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void query_child_state_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void query_child_state_request::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

uint32_t query_child_state_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_child_state_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_child_state_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_child_state_request &a, query_child_state_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.pid, b.pid);
  swap(a.partition_count, b.partition_count);
  swap(a.__isset, b.__isset);
}

query_child_state_request::query_child_state_request(const query_child_state_request& other39) {
  app_name = other39.app_name;
  pid = other39.pid;
  partition_count = other39.partition_count;
  __isset = other39.__isset;
}
query_child_state_request& query_child_state_request::operator=(const query_child_state_request& other40) {
  app_name = other40.app_name;
  pid = other40.pid;
  partition_count = other40.partition_count;
  __isset = other40.__isset;
  return *this;
}
void query_child_state_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_child_state_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "pid=" << to_string(pid);
  out << ", " << "partition_count=" << to_string(partition_count);
  out << ")";
}


query_child_state_response::~query_child_state_response() throw() {
}


void query_child_state_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_child_state_response::__set_partition_count(const int32_t val) {
  this->partition_count = val;
__isset.partition_count = true;
}

void query_child_state_response::__set_child_config(const  ::dsn::partition_configuration& val) {
  this->child_config = val;
__isset.child_config = true;
}

uint32_t query_child_state_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_config.read(iprot);
          this->__isset.child_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_child_state_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_child_state_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_count) {
    xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->partition_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_config) {
    xfer += oprot->writeFieldBegin("child_config", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->child_config.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_child_state_response &a, query_child_state_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partition_count, b.partition_count);
  swap(a.child_config, b.child_config);
  swap(a.__isset, b.__isset);
}

query_child_state_response::query_child_state_response(const query_child_state_response& other41) {
  err = other41.err;
  partition_count = other41.partition_count;
  child_config = other41.child_config;
  __isset = other41.__isset;
}
query_child_state_response& query_child_state_response::operator=(const query_child_state_response& other42) {
  err = other42.err;
  partition_count = other42.partition_count;
  child_config = other42.child_config;
  __isset = other42.__isset;
  return *this;
}
void query_child_state_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_child_state_response(";
  out << "err=" << to_string(err);
  out << ", " << "partition_count="; (__isset.partition_count ? (out << to_string(partition_count)) : (out << "<null>"));
  out << ", " << "child_config="; (__isset.child_config ? (out << to_string(child_config)) : (out << "<null>"));
  out << ")";
}

}} // namespace
