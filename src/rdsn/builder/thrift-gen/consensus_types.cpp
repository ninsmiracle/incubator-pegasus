/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "consensus_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kread_semanticValues[] = {
  read_semantic::ReadInvalid,
  read_semantic::ReadLastUpdate,
  read_semantic::ReadOutdated,
  read_semantic::ReadSnapshot
};
const char* _kread_semanticNames[] = {
  "ReadInvalid",
  "ReadLastUpdate",
  "ReadOutdated",
  "ReadSnapshot"
};
const std::map<int, const char*> _read_semantic_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kread_semanticValues, _kread_semanticNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _klearn_typeValues[] = {
  learn_type::LT_INVALID,
  learn_type::LT_CACHE,
  learn_type::LT_APP,
  learn_type::LT_LOG
};
const char* _klearn_typeNames[] = {
  "LT_INVALID",
  "LT_CACHE",
  "LT_APP",
  "LT_LOG"
};
const std::map<int, const char*> _learn_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _klearn_typeValues, _klearn_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _klearner_statusValues[] = {
  learner_status::LearningInvalid,
  learner_status::LearningWithoutPrepare,
  learner_status::LearningWithPrepareTransient,
  learner_status::LearningWithPrepare,
  learner_status::LearningSucceeded,
  learner_status::LearningFailed
};
const char* _klearner_statusNames[] = {
  "LearningInvalid",
  "LearningWithoutPrepare",
  "LearningWithPrepareTransient",
  "LearningWithPrepare",
  "LearningSucceeded",
  "LearningFailed"
};
const std::map<int, const char*> _learner_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _klearner_statusValues, _klearner_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


mutation_header::~mutation_header() throw() {
}


void mutation_header::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void mutation_header::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void mutation_header::__set_decree(const int64_t val) {
  this->decree = val;
}

void mutation_header::__set_log_offset(const int64_t val) {
  this->log_offset = val;
}

void mutation_header::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void mutation_header::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

uint32_t mutation_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->decree);
          this->__isset.decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->log_offset);
          this->__isset.log_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_header");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log_offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->log_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_header &a, mutation_header &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.ballot, b.ballot);
  swap(a.decree, b.decree);
  swap(a.log_offset, b.log_offset);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

mutation_header::mutation_header(const mutation_header& other0) {
  pid = other0.pid;
  ballot = other0.ballot;
  decree = other0.decree;
  log_offset = other0.log_offset;
  last_committed_decree = other0.last_committed_decree;
  timestamp = other0.timestamp;
  __isset = other0.__isset;
}
mutation_header& mutation_header::operator=(const mutation_header& other1) {
  pid = other1.pid;
  ballot = other1.ballot;
  decree = other1.decree;
  log_offset = other1.log_offset;
  last_committed_decree = other1.last_committed_decree;
  timestamp = other1.timestamp;
  __isset = other1.__isset;
  return *this;
}
void mutation_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_header(";
  out << "pid=" << to_string(pid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "decree=" << to_string(decree);
  out << ", " << "log_offset=" << to_string(log_offset);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


mutation_update::~mutation_update() throw() {
}


void mutation_update::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

void mutation_update::__set_serialization_type(const int32_t val) {
  this->serialization_type = val;
}

void mutation_update::__set_data(const  ::dsn::blob& val) {
  this->data = val;
}

void mutation_update::__set_start_time_ns(const int64_t val) {
  this->start_time_ns = val;
__isset.start_time_ns = true;
}

uint32_t mutation_update::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->serialization_type);
          this->__isset.serialization_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time_ns);
          this->__isset.start_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_update::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_update");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serialization_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->serialization_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.start_time_ns) {
    xfer += oprot->writeFieldBegin("start_time_ns", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->start_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_update &a, mutation_update &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.serialization_type, b.serialization_type);
  swap(a.data, b.data);
  swap(a.start_time_ns, b.start_time_ns);
  swap(a.__isset, b.__isset);
}

mutation_update::mutation_update(const mutation_update& other2) {
  code = other2.code;
  serialization_type = other2.serialization_type;
  data = other2.data;
  start_time_ns = other2.start_time_ns;
  __isset = other2.__isset;
}
mutation_update& mutation_update::operator=(const mutation_update& other3) {
  code = other3.code;
  serialization_type = other3.serialization_type;
  data = other3.data;
  start_time_ns = other3.start_time_ns;
  __isset = other3.__isset;
  return *this;
}
void mutation_update::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_update(";
  out << "code=" << to_string(code);
  out << ", " << "serialization_type=" << to_string(serialization_type);
  out << ", " << "data=" << to_string(data);
  out << ", " << "start_time_ns="; (__isset.start_time_ns ? (out << to_string(start_time_ns)) : (out << "<null>"));
  out << ")";
}


mutation_data::~mutation_data() throw() {
}


void mutation_data::__set_header(const mutation_header& val) {
  this->header = val;
}

void mutation_data::__set_updates(const std::vector<mutation_update> & val) {
  this->updates = val;
}

uint32_t mutation_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->updates.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->updates[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_data");

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<mutation_update> ::const_iterator _iter9;
    for (_iter9 = this->updates.begin(); _iter9 != this->updates.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_data &a, mutation_data &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.updates, b.updates);
  swap(a.__isset, b.__isset);
}

mutation_data::mutation_data(const mutation_data& other10) {
  header = other10.header;
  updates = other10.updates;
  __isset = other10.__isset;
}
mutation_data& mutation_data::operator=(const mutation_data& other11) {
  header = other11.header;
  updates = other11.updates;
  __isset = other11.__isset;
  return *this;
}
void mutation_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_data(";
  out << "header=" << to_string(header);
  out << ", " << "updates=" << to_string(updates);
  out << ")";
}


prepare_msg::~prepare_msg() throw() {
}


void prepare_msg::__set_config(const  ::dsn::replication::replica_configuration& val) {
  this->config = val;
}

void prepare_msg::__set_mu(const mutation_data& val) {
  this->mu = val;
}

uint32_t prepare_msg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mu.read(iprot);
          this->__isset.mu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t prepare_msg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("prepare_msg");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mu", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mu.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(prepare_msg &a, prepare_msg &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.mu, b.mu);
  swap(a.__isset, b.__isset);
}

prepare_msg::prepare_msg(const prepare_msg& other12) {
  config = other12.config;
  mu = other12.mu;
  __isset = other12.__isset;
}
prepare_msg& prepare_msg::operator=(const prepare_msg& other13) {
  config = other13.config;
  mu = other13.mu;
  __isset = other13.__isset;
  return *this;
}
void prepare_msg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "prepare_msg(";
  out << "config=" << to_string(config);
  out << ", " << "mu=" << to_string(mu);
  out << ")";
}


read_request_header::~read_request_header() throw() {
}


void read_request_header::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void read_request_header::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

void read_request_header::__set_semantic(const read_semantic::type val) {
  this->semantic = val;
}

void read_request_header::__set_version_decree(const int64_t val) {
  this->version_decree = val;
}

uint32_t read_request_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->semantic = (read_semantic::type)ecast14;
          this->__isset.semantic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_decree);
          this->__isset.version_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t read_request_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("read_request_header");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("semantic", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->semantic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(read_request_header &a, read_request_header &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.code, b.code);
  swap(a.semantic, b.semantic);
  swap(a.version_decree, b.version_decree);
  swap(a.__isset, b.__isset);
}

read_request_header::read_request_header(const read_request_header& other15) {
  pid = other15.pid;
  code = other15.code;
  semantic = other15.semantic;
  version_decree = other15.version_decree;
  __isset = other15.__isset;
}
read_request_header& read_request_header::operator=(const read_request_header& other16) {
  pid = other16.pid;
  code = other16.code;
  semantic = other16.semantic;
  version_decree = other16.version_decree;
  __isset = other16.__isset;
  return *this;
}
void read_request_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "read_request_header(";
  out << "pid=" << to_string(pid);
  out << ", " << "code=" << to_string(code);
  out << ", " << "semantic=" << to_string(semantic);
  out << ", " << "version_decree=" << to_string(version_decree);
  out << ")";
}


write_request_header::~write_request_header() throw() {
}


void write_request_header::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void write_request_header::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

uint32_t write_request_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t write_request_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("write_request_header");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(write_request_header &a, write_request_header &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

write_request_header::write_request_header(const write_request_header& other17) {
  pid = other17.pid;
  code = other17.code;
  __isset = other17.__isset;
}
write_request_header& write_request_header::operator=(const write_request_header& other18) {
  pid = other18.pid;
  code = other18.code;
  __isset = other18.__isset;
  return *this;
}
void write_request_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "write_request_header(";
  out << "pid=" << to_string(pid);
  out << ", " << "code=" << to_string(code);
  out << ")";
}


rw_response_header::~rw_response_header() throw() {
}


void rw_response_header::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t rw_response_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rw_response_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rw_response_header");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(rw_response_header &a, rw_response_header &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

rw_response_header::rw_response_header(const rw_response_header& other19) {
  err = other19.err;
  __isset = other19.__isset;
}
rw_response_header& rw_response_header::operator=(const rw_response_header& other20) {
  err = other20.err;
  __isset = other20.__isset;
  return *this;
}
void rw_response_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rw_response_header(";
  out << "err=" << to_string(err);
  out << ")";
}


prepare_ack::~prepare_ack() throw() {
}


void prepare_ack::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void prepare_ack::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void prepare_ack::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void prepare_ack::__set_decree(const int64_t val) {
  this->decree = val;
}

void prepare_ack::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void prepare_ack::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

void prepare_ack::__set_receive_timestamp(const int64_t val) {
  this->receive_timestamp = val;
__isset.receive_timestamp = true;
}

void prepare_ack::__set_response_timestamp(const int64_t val) {
  this->response_timestamp = val;
__isset.response_timestamp = true;
}

uint32_t prepare_ack::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->decree);
          this->__isset.decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->receive_timestamp);
          this->__isset.receive_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->response_timestamp);
          this->__isset.response_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t prepare_ack::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("prepare_ack");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.receive_timestamp) {
    xfer += oprot->writeFieldBegin("receive_timestamp", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->receive_timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.response_timestamp) {
    xfer += oprot->writeFieldBegin("response_timestamp", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->response_timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(prepare_ack &a, prepare_ack &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.err, b.err);
  swap(a.ballot, b.ballot);
  swap(a.decree, b.decree);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.receive_timestamp, b.receive_timestamp);
  swap(a.response_timestamp, b.response_timestamp);
  swap(a.__isset, b.__isset);
}

prepare_ack::prepare_ack(const prepare_ack& other21) {
  pid = other21.pid;
  err = other21.err;
  ballot = other21.ballot;
  decree = other21.decree;
  last_committed_decree_in_app = other21.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other21.last_committed_decree_in_prepare_list;
  receive_timestamp = other21.receive_timestamp;
  response_timestamp = other21.response_timestamp;
  __isset = other21.__isset;
}
prepare_ack& prepare_ack::operator=(const prepare_ack& other22) {
  pid = other22.pid;
  err = other22.err;
  ballot = other22.ballot;
  decree = other22.decree;
  last_committed_decree_in_app = other22.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other22.last_committed_decree_in_prepare_list;
  receive_timestamp = other22.receive_timestamp;
  response_timestamp = other22.response_timestamp;
  __isset = other22.__isset;
  return *this;
}
void prepare_ack::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "prepare_ack(";
  out << "pid=" << to_string(pid);
  out << ", " << "err=" << to_string(err);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "decree=" << to_string(decree);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ", " << "receive_timestamp="; (__isset.receive_timestamp ? (out << to_string(receive_timestamp)) : (out << "<null>"));
  out << ", " << "response_timestamp="; (__isset.response_timestamp ? (out << to_string(response_timestamp)) : (out << "<null>"));
  out << ")";
}


learn_state::~learn_state() throw() {
}


void learn_state::__set_from_decree_excluded(const int64_t val) {
  this->from_decree_excluded = val;
}

void learn_state::__set_to_decree_included(const int64_t val) {
  this->to_decree_included = val;
}

void learn_state::__set_meta(const  ::dsn::blob& val) {
  this->meta = val;
}

void learn_state::__set_files(const std::vector<std::string> & val) {
  this->files = val;
}

void learn_state::__set_learn_start_decree(const int64_t val) {
  this->learn_start_decree = val;
__isset.learn_start_decree = true;
}

uint32_t learn_state::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->from_decree_excluded);
          this->__isset.from_decree_excluded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->to_decree_included);
          this->__isset.to_decree_included = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta.read(iprot);
          this->__isset.meta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->files.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->files[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->learn_start_decree);
          this->__isset.learn_start_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_state::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_state");

  xfer += oprot->writeFieldBegin("from_decree_excluded", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->from_decree_excluded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_decree_included", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->to_decree_included);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meta", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->meta.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
    std::vector<std::string> ::const_iterator _iter28;
    for (_iter28 = this->files.begin(); _iter28 != this->files.end(); ++_iter28)
    {
      xfer += oprot->writeString((*_iter28));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.learn_start_decree) {
    xfer += oprot->writeFieldBegin("learn_start_decree", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->learn_start_decree);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_state &a, learn_state &b) {
  using ::std::swap;
  swap(a.from_decree_excluded, b.from_decree_excluded);
  swap(a.to_decree_included, b.to_decree_included);
  swap(a.meta, b.meta);
  swap(a.files, b.files);
  swap(a.learn_start_decree, b.learn_start_decree);
  swap(a.__isset, b.__isset);
}

learn_state::learn_state(const learn_state& other29) {
  from_decree_excluded = other29.from_decree_excluded;
  to_decree_included = other29.to_decree_included;
  meta = other29.meta;
  files = other29.files;
  learn_start_decree = other29.learn_start_decree;
  __isset = other29.__isset;
}
learn_state& learn_state::operator=(const learn_state& other30) {
  from_decree_excluded = other30.from_decree_excluded;
  to_decree_included = other30.to_decree_included;
  meta = other30.meta;
  files = other30.files;
  learn_start_decree = other30.learn_start_decree;
  __isset = other30.__isset;
  return *this;
}
void learn_state::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_state(";
  out << "from_decree_excluded=" << to_string(from_decree_excluded);
  out << ", " << "to_decree_included=" << to_string(to_decree_included);
  out << ", " << "meta=" << to_string(meta);
  out << ", " << "files=" << to_string(files);
  out << ", " << "learn_start_decree="; (__isset.learn_start_decree ? (out << to_string(learn_start_decree)) : (out << "<null>"));
  out << ")";
}


learn_request::~learn_request() throw() {
}


void learn_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void learn_request::__set_learner(const  ::dsn::rpc_address& val) {
  this->learner = val;
}

void learn_request::__set_signature(const int64_t val) {
  this->signature = val;
}

void learn_request::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void learn_request::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

void learn_request::__set_app_specific_learn_request(const  ::dsn::blob& val) {
  this->app_specific_learn_request = val;
}

void learn_request::__set_max_gced_decree(const int64_t val) {
  this->max_gced_decree = val;
__isset.max_gced_decree = true;
}

uint32_t learn_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->learner.read(iprot);
          this->__isset.learner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app_specific_learn_request.read(iprot);
          this->__isset.app_specific_learn_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_gced_decree);
          this->__isset.max_gced_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->learner.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_specific_learn_request", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->app_specific_learn_request.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.max_gced_decree) {
    xfer += oprot->writeFieldBegin("max_gced_decree", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->max_gced_decree);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_request &a, learn_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.learner, b.learner);
  swap(a.signature, b.signature);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.app_specific_learn_request, b.app_specific_learn_request);
  swap(a.max_gced_decree, b.max_gced_decree);
  swap(a.__isset, b.__isset);
}

learn_request::learn_request(const learn_request& other31) {
  pid = other31.pid;
  learner = other31.learner;
  signature = other31.signature;
  last_committed_decree_in_app = other31.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other31.last_committed_decree_in_prepare_list;
  app_specific_learn_request = other31.app_specific_learn_request;
  max_gced_decree = other31.max_gced_decree;
  __isset = other31.__isset;
}
learn_request& learn_request::operator=(const learn_request& other32) {
  pid = other32.pid;
  learner = other32.learner;
  signature = other32.signature;
  last_committed_decree_in_app = other32.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other32.last_committed_decree_in_prepare_list;
  app_specific_learn_request = other32.app_specific_learn_request;
  max_gced_decree = other32.max_gced_decree;
  __isset = other32.__isset;
  return *this;
}
void learn_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "learner=" << to_string(learner);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ", " << "app_specific_learn_request=" << to_string(app_specific_learn_request);
  out << ", " << "max_gced_decree="; (__isset.max_gced_decree ? (out << to_string(max_gced_decree)) : (out << "<null>"));
  out << ")";
}


learn_response::~learn_response() throw() {
}


void learn_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void learn_response::__set_config(const  ::dsn::replication::replica_configuration& val) {
  this->config = val;
}

void learn_response::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void learn_response::__set_prepare_start_decree(const int64_t val) {
  this->prepare_start_decree = val;
}

void learn_response::__set_type(const learn_type::type val) {
  this->type = val;
}

void learn_response::__set_state(const learn_state& val) {
  this->state = val;
}

void learn_response::__set_address(const  ::dsn::rpc_address& val) {
  this->address = val;
}

void learn_response::__set_base_local_dir(const std::string& val) {
  this->base_local_dir = val;
}

void learn_response::__set_replica_disk_tag(const std::string& val) {
  this->replica_disk_tag = val;
__isset.replica_disk_tag = true;
}

uint32_t learn_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->prepare_start_decree);
          this->__isset.prepare_start_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->type = (learn_type::type)ecast33;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->state.read(iprot);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base_local_dir);
          this->__isset.base_local_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_disk_tag);
          this->__isset.replica_disk_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prepare_start_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->prepare_start_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->state.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("base_local_dir", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->base_local_dir);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.replica_disk_tag) {
    xfer += oprot->writeFieldBegin("replica_disk_tag", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->replica_disk_tag);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_response &a, learn_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.config, b.config);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.prepare_start_decree, b.prepare_start_decree);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.address, b.address);
  swap(a.base_local_dir, b.base_local_dir);
  swap(a.replica_disk_tag, b.replica_disk_tag);
  swap(a.__isset, b.__isset);
}

learn_response::learn_response(const learn_response& other34) {
  err = other34.err;
  config = other34.config;
  last_committed_decree = other34.last_committed_decree;
  prepare_start_decree = other34.prepare_start_decree;
  type = other34.type;
  state = other34.state;
  address = other34.address;
  base_local_dir = other34.base_local_dir;
  replica_disk_tag = other34.replica_disk_tag;
  __isset = other34.__isset;
}
learn_response& learn_response::operator=(const learn_response& other35) {
  err = other35.err;
  config = other35.config;
  last_committed_decree = other35.last_committed_decree;
  prepare_start_decree = other35.prepare_start_decree;
  type = other35.type;
  state = other35.state;
  address = other35.address;
  base_local_dir = other35.base_local_dir;
  replica_disk_tag = other35.replica_disk_tag;
  __isset = other35.__isset;
  return *this;
}
void learn_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_response(";
  out << "err=" << to_string(err);
  out << ", " << "config=" << to_string(config);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "prepare_start_decree=" << to_string(prepare_start_decree);
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "address=" << to_string(address);
  out << ", " << "base_local_dir=" << to_string(base_local_dir);
  out << ", " << "replica_disk_tag="; (__isset.replica_disk_tag ? (out << to_string(replica_disk_tag)) : (out << "<null>"));
  out << ")";
}


learn_notify_response::~learn_notify_response() throw() {
}


void learn_notify_response::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void learn_notify_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void learn_notify_response::__set_signature(const int64_t val) {
  this->signature = val;
}

uint32_t learn_notify_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_notify_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_notify_response");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_notify_response &a, learn_notify_response &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.err, b.err);
  swap(a.signature, b.signature);
  swap(a.__isset, b.__isset);
}

learn_notify_response::learn_notify_response(const learn_notify_response& other36) {
  pid = other36.pid;
  err = other36.err;
  signature = other36.signature;
  __isset = other36.__isset;
}
learn_notify_response& learn_notify_response::operator=(const learn_notify_response& other37) {
  pid = other37.pid;
  err = other37.err;
  signature = other37.signature;
  __isset = other37.__isset;
  return *this;
}
void learn_notify_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_notify_response(";
  out << "pid=" << to_string(pid);
  out << ", " << "err=" << to_string(err);
  out << ", " << "signature=" << to_string(signature);
  out << ")";
}


group_check_request::~group_check_request() throw() {
}


void group_check_request::__set_app(const  ::dsn::app_info& val) {
  this->app = val;
}

void group_check_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void group_check_request::__set_config(const  ::dsn::replication::replica_configuration& val) {
  this->config = val;
}

void group_check_request::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void group_check_request::__set_confirmed_decree(const int64_t val) {
  this->confirmed_decree = val;
__isset.confirmed_decree = true;
}

void group_check_request::__set_child_gpid(const  ::dsn::gpid& val) {
  this->child_gpid = val;
__isset.child_gpid = true;
}

void group_check_request::__set_meta_split_status(const  ::dsn::replication::split_status::type val) {
  this->meta_split_status = val;
__isset.meta_split_status = true;
}

uint32_t group_check_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app.read(iprot);
          this->__isset.app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->confirmed_decree);
          this->__isset.confirmed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->child_gpid.read(iprot);
          this->__isset.child_gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->meta_split_status = ( ::dsn::replication::split_status::type)ecast38;
          this->__isset.meta_split_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_check_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_check_request");

  xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->app.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.confirmed_decree) {
    xfer += oprot->writeFieldBegin("confirmed_decree", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->confirmed_decree);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_gpid) {
    xfer += oprot->writeFieldBegin("child_gpid", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->child_gpid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.meta_split_status) {
    xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->meta_split_status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_check_request &a, group_check_request &b) {
  using ::std::swap;
  swap(a.app, b.app);
  swap(a.node, b.node);
  swap(a.config, b.config);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.confirmed_decree, b.confirmed_decree);
  swap(a.child_gpid, b.child_gpid);
  swap(a.meta_split_status, b.meta_split_status);
  swap(a.__isset, b.__isset);
}

group_check_request::group_check_request(const group_check_request& other39) {
  app = other39.app;
  node = other39.node;
  config = other39.config;
  last_committed_decree = other39.last_committed_decree;
  confirmed_decree = other39.confirmed_decree;
  child_gpid = other39.child_gpid;
  meta_split_status = other39.meta_split_status;
  __isset = other39.__isset;
}
group_check_request& group_check_request::operator=(const group_check_request& other40) {
  app = other40.app;
  node = other40.node;
  config = other40.config;
  last_committed_decree = other40.last_committed_decree;
  confirmed_decree = other40.confirmed_decree;
  child_gpid = other40.child_gpid;
  meta_split_status = other40.meta_split_status;
  __isset = other40.__isset;
  return *this;
}
void group_check_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_check_request(";
  out << "app=" << to_string(app);
  out << ", " << "node=" << to_string(node);
  out << ", " << "config=" << to_string(config);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "confirmed_decree="; (__isset.confirmed_decree ? (out << to_string(confirmed_decree)) : (out << "<null>"));
  out << ", " << "child_gpid="; (__isset.child_gpid ? (out << to_string(child_gpid)) : (out << "<null>"));
  out << ", " << "meta_split_status="; (__isset.meta_split_status ? (out << to_string(meta_split_status)) : (out << "<null>"));
  out << ")";
}


group_check_response::~group_check_response() throw() {
}


void group_check_response::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void group_check_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void group_check_response::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void group_check_response::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

void group_check_response::__set_learner_status_(const learner_status::type val) {
  this->learner_status_ = val;
}

void group_check_response::__set_learner_signature(const int64_t val) {
  this->learner_signature = val;
}

void group_check_response::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void group_check_response::__set_is_split_stopped(const bool val) {
  this->is_split_stopped = val;
__isset.is_split_stopped = true;
}

void group_check_response::__set_disk_status(const  ::dsn::replication::disk_status::type val) {
  this->disk_status = val;
__isset.disk_status = true;
}

uint32_t group_check_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->learner_status_ = (learner_status::type)ecast41;
          this->__isset.learner_status_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->learner_signature);
          this->__isset.learner_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_split_stopped);
          this->__isset.is_split_stopped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->disk_status = ( ::dsn::replication::disk_status::type)ecast42;
          this->__isset.disk_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_check_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_check_response");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner_status_", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->learner_status_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner_signature", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->learner_signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_split_stopped) {
    xfer += oprot->writeFieldBegin("is_split_stopped", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_split_stopped);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_status) {
    xfer += oprot->writeFieldBegin("disk_status", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->disk_status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_check_response &a, group_check_response &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.err, b.err);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.learner_status_, b.learner_status_);
  swap(a.learner_signature, b.learner_signature);
  swap(a.node, b.node);
  swap(a.is_split_stopped, b.is_split_stopped);
  swap(a.disk_status, b.disk_status);
  swap(a.__isset, b.__isset);
}

group_check_response::group_check_response(const group_check_response& other43) {
  pid = other43.pid;
  err = other43.err;
  last_committed_decree_in_app = other43.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other43.last_committed_decree_in_prepare_list;
  learner_status_ = other43.learner_status_;
  learner_signature = other43.learner_signature;
  node = other43.node;
  is_split_stopped = other43.is_split_stopped;
  disk_status = other43.disk_status;
  __isset = other43.__isset;
}
group_check_response& group_check_response::operator=(const group_check_response& other44) {
  pid = other44.pid;
  err = other44.err;
  last_committed_decree_in_app = other44.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other44.last_committed_decree_in_prepare_list;
  learner_status_ = other44.learner_status_;
  learner_signature = other44.learner_signature;
  node = other44.node;
  is_split_stopped = other44.is_split_stopped;
  disk_status = other44.disk_status;
  __isset = other44.__isset;
  return *this;
}
void group_check_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_check_response(";
  out << "pid=" << to_string(pid);
  out << ", " << "err=" << to_string(err);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ", " << "learner_status_=" << to_string(learner_status_);
  out << ", " << "learner_signature=" << to_string(learner_signature);
  out << ", " << "node=" << to_string(node);
  out << ", " << "is_split_stopped="; (__isset.is_split_stopped ? (out << to_string(is_split_stopped)) : (out << "<null>"));
  out << ", " << "disk_status="; (__isset.disk_status ? (out << to_string(disk_status)) : (out << "<null>"));
  out << ")";
}

}} // namespace
