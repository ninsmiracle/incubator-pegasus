/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "meta_admin_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kconfig_typeValues[] = {
  config_type::CT_INVALID,
  config_type::CT_ASSIGN_PRIMARY,
  config_type::CT_UPGRADE_TO_PRIMARY,
  config_type::CT_ADD_SECONDARY,
  config_type::CT_UPGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_INACTIVE,
  config_type::CT_REMOVE,
  config_type::CT_ADD_SECONDARY_FOR_LB,
  config_type::CT_PRIMARY_FORCE_UPDATE_BALLOT,
  config_type::CT_DROP_PARTITION,
  config_type::CT_REGISTER_CHILD
};
const char* _kconfig_typeNames[] = {
  "CT_INVALID",
  "CT_ASSIGN_PRIMARY",
  "CT_UPGRADE_TO_PRIMARY",
  "CT_ADD_SECONDARY",
  "CT_UPGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_INACTIVE",
  "CT_REMOVE",
  "CT_ADD_SECONDARY_FOR_LB",
  "CT_PRIMARY_FORCE_UPDATE_BALLOT",
  "CT_DROP_PARTITION",
  "CT_REGISTER_CHILD"
};
const std::map<int, const char*> _config_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kconfig_typeValues, _kconfig_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _knode_statusValues[] = {
  node_status::NS_INVALID,
  node_status::NS_ALIVE,
  node_status::NS_UNALIVE
};
const char* _knode_statusNames[] = {
  "NS_INVALID",
  "NS_ALIVE",
  "NS_UNALIVE"
};
const std::map<int, const char*> _node_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _knode_statusValues, _knode_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kapp_env_operationValues[] = {
  app_env_operation::APP_ENV_OP_INVALID,
  app_env_operation::APP_ENV_OP_SET,
  app_env_operation::APP_ENV_OP_DEL,
  app_env_operation::APP_ENV_OP_CLEAR
};
const char* _kapp_env_operationNames[] = {
  "APP_ENV_OP_INVALID",
  "APP_ENV_OP_SET",
  "APP_ENV_OP_DEL",
  "APP_ENV_OP_CLEAR"
};
const std::map<int, const char*> _app_env_operation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kapp_env_operationValues, _kapp_env_operationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kmeta_function_levelValues[] = {
  meta_function_level::fl_stopped,
  meta_function_level::fl_blind,
  meta_function_level::fl_freezed,
  meta_function_level::fl_steady,
  meta_function_level::fl_lively,
  meta_function_level::fl_invalid
};
const char* _kmeta_function_levelNames[] = {
  "fl_stopped",
  "fl_blind",
  "fl_freezed",
  "fl_steady",
  "fl_lively",
  "fl_invalid"
};
const std::map<int, const char*> _meta_function_level_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kmeta_function_levelValues, _kmeta_function_levelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbalancer_request_typeValues[] = {
  balancer_request_type::move_primary,
  balancer_request_type::copy_primary,
  balancer_request_type::copy_secondary
};
const char* _kbalancer_request_typeNames[] = {
  "move_primary",
  "copy_primary",
  "copy_secondary"
};
const std::map<int, const char*> _balancer_request_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kbalancer_request_typeValues, _kbalancer_request_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


configuration_update_request::~configuration_update_request() throw() {
}


void configuration_update_request::__set_info(const  ::dsn::app_info& val) {
  this->info = val;
}

void configuration_update_request::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

void configuration_update_request::__set_type(const config_type::type val) {
  this->type = val;
}

void configuration_update_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_update_request::__set_host_node(const  ::dsn::rpc_address& val) {
  this->host_node = val;
}

void configuration_update_request::__set_meta_split_status(const  ::dsn::replication::split_status::type val) {
  this->meta_split_status = val;
__isset.meta_split_status = true;
}

uint32_t configuration_update_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (config_type::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->host_node.read(iprot);
          this->__isset.host_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->meta_split_status = ( ::dsn::replication::split_status::type)ecast1;
          this->__isset.meta_split_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_request");

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_node", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->host_node.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.meta_split_status) {
    xfer += oprot->writeFieldBegin("meta_split_status", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->meta_split_status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_request &a, configuration_update_request &b) {
  using ::std::swap;
  swap(a.info, b.info);
  swap(a.config, b.config);
  swap(a.type, b.type);
  swap(a.node, b.node);
  swap(a.host_node, b.host_node);
  swap(a.meta_split_status, b.meta_split_status);
  swap(a.__isset, b.__isset);
}

configuration_update_request::configuration_update_request(const configuration_update_request& other2) {
  info = other2.info;
  config = other2.config;
  type = other2.type;
  node = other2.node;
  host_node = other2.host_node;
  meta_split_status = other2.meta_split_status;
  __isset = other2.__isset;
}
configuration_update_request& configuration_update_request::operator=(const configuration_update_request& other3) {
  info = other3.info;
  config = other3.config;
  type = other3.type;
  node = other3.node;
  host_node = other3.host_node;
  meta_split_status = other3.meta_split_status;
  __isset = other3.__isset;
  return *this;
}
void configuration_update_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_request(";
  out << "info=" << to_string(info);
  out << ", " << "config=" << to_string(config);
  out << ", " << "type=" << to_string(type);
  out << ", " << "node=" << to_string(node);
  out << ", " << "host_node=" << to_string(host_node);
  out << ", " << "meta_split_status="; (__isset.meta_split_status ? (out << to_string(meta_split_status)) : (out << "<null>"));
  out << ")";
}


configuration_update_response::~configuration_update_response() throw() {
}


void configuration_update_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_update_response::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

uint32_t configuration_update_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_response &a, configuration_update_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

configuration_update_response::configuration_update_response(const configuration_update_response& other4) {
  err = other4.err;
  config = other4.config;
  __isset = other4.__isset;
}
configuration_update_response& configuration_update_response::operator=(const configuration_update_response& other5) {
  err = other5.err;
  config = other5.config;
  __isset = other5.__isset;
  return *this;
}
void configuration_update_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_response(";
  out << "err=" << to_string(err);
  out << ", " << "config=" << to_string(config);
  out << ")";
}


replica_server_info::~replica_server_info() throw() {
}


void replica_server_info::__set_geo_tags(const std::map<std::string, std::string> & val) {
  this->geo_tags = val;
}

void replica_server_info::__set_total_capacity_mb(const int64_t val) {
  this->total_capacity_mb = val;
}

uint32_t replica_server_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->geo_tags.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->geo_tags[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.geo_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_capacity_mb);
          this->__isset.total_capacity_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_server_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_server_info");

  xfer += oprot->writeFieldBegin("geo_tags", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->geo_tags.size()));
    std::map<std::string, std::string> ::const_iterator _iter13;
    for (_iter13 = this->geo_tags.begin(); _iter13 != this->geo_tags.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_capacity_mb", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->total_capacity_mb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_server_info &a, replica_server_info &b) {
  using ::std::swap;
  swap(a.geo_tags, b.geo_tags);
  swap(a.total_capacity_mb, b.total_capacity_mb);
  swap(a.__isset, b.__isset);
}

replica_server_info::replica_server_info(const replica_server_info& other14) {
  geo_tags = other14.geo_tags;
  total_capacity_mb = other14.total_capacity_mb;
  __isset = other14.__isset;
}
replica_server_info& replica_server_info::operator=(const replica_server_info& other15) {
  geo_tags = other15.geo_tags;
  total_capacity_mb = other15.total_capacity_mb;
  __isset = other15.__isset;
  return *this;
}
void replica_server_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_server_info(";
  out << "geo_tags=" << to_string(geo_tags);
  out << ", " << "total_capacity_mb=" << to_string(total_capacity_mb);
  out << ")";
}


configuration_query_by_node_request::~configuration_query_by_node_request() throw() {
}


void configuration_query_by_node_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_query_by_node_request::__set_stored_replicas(const std::vector< ::dsn::replication::replica_info> & val) {
  this->stored_replicas = val;
__isset.stored_replicas = true;
}

void configuration_query_by_node_request::__set_info(const replica_server_info& val) {
  this->info = val;
__isset.info = true;
}

void configuration_query_by_node_request::__set_partition_storage(const std::map< ::dsn::gpid, int32_t> & val) {
  this->partition_storage = val;
}

void configuration_query_by_node_request::__set_disk_storage(const std::map<std::string, int32_t> & val) {
  this->disk_storage = val;
}

uint32_t configuration_query_by_node_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stored_replicas.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->stored_replicas.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->stored_replicas[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stored_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partition_storage.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _ktype22;
            ::apache::thrift::protocol::TType _vtype23;
            xfer += iprot->readMapBegin(_ktype22, _vtype23, _size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
               ::dsn::gpid _key26;
              xfer += _key26.read(iprot);
              int32_t& _val27 = this->partition_storage[_key26];
              xfer += iprot->readI32(_val27);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.partition_storage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disk_storage.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _ktype29;
            ::apache::thrift::protocol::TType _vtype30;
            xfer += iprot->readMapBegin(_ktype29, _vtype30, _size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              std::string _key33;
              xfer += iprot->readString(_key33);
              int32_t& _val34 = this->disk_storage[_key33];
              xfer += iprot->readI32(_val34);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disk_storage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stored_replicas) {
    xfer += oprot->writeFieldBegin("stored_replicas", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stored_replicas.size()));
      std::vector< ::dsn::replication::replica_info> ::const_iterator _iter35;
      for (_iter35 = this->stored_replicas.begin(); _iter35 != this->stored_replicas.end(); ++_iter35)
      {
        xfer += (*_iter35).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.info) {
    xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("partition_storage", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->partition_storage.size()));
    std::map< ::dsn::gpid, int32_t> ::const_iterator _iter36;
    for (_iter36 = this->partition_storage.begin(); _iter36 != this->partition_storage.end(); ++_iter36)
    {
      xfer += _iter36->first.write(oprot);
      xfer += oprot->writeI32(_iter36->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disk_storage", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->disk_storage.size()));
    std::map<std::string, int32_t> ::const_iterator _iter37;
    for (_iter37 = this->disk_storage.begin(); _iter37 != this->disk_storage.end(); ++_iter37)
    {
      xfer += oprot->writeString(_iter37->first);
      xfer += oprot->writeI32(_iter37->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.stored_replicas, b.stored_replicas);
  swap(a.info, b.info);
  swap(a.partition_storage, b.partition_storage);
  swap(a.disk_storage, b.disk_storage);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_request::configuration_query_by_node_request(const configuration_query_by_node_request& other38) {
  node = other38.node;
  stored_replicas = other38.stored_replicas;
  info = other38.info;
  partition_storage = other38.partition_storage;
  disk_storage = other38.disk_storage;
  __isset = other38.__isset;
}
configuration_query_by_node_request& configuration_query_by_node_request::operator=(const configuration_query_by_node_request& other39) {
  node = other39.node;
  stored_replicas = other39.stored_replicas;
  info = other39.info;
  partition_storage = other39.partition_storage;
  disk_storage = other39.disk_storage;
  __isset = other39.__isset;
  return *this;
}
void configuration_query_by_node_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_request(";
  out << "node=" << to_string(node);
  out << ", " << "stored_replicas="; (__isset.stored_replicas ? (out << to_string(stored_replicas)) : (out << "<null>"));
  out << ", " << "info="; (__isset.info ? (out << to_string(info)) : (out << "<null>"));
  out << ", " << "partition_storage=" << to_string(partition_storage);
  out << ", " << "disk_storage=" << to_string(disk_storage);
  out << ")";
}


configuration_query_by_node_response::~configuration_query_by_node_response() throw() {
}


void configuration_query_by_node_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_by_node_response::__set_partitions(const std::vector<configuration_update_request> & val) {
  this->partitions = val;
}

void configuration_query_by_node_response::__set_gc_replicas(const std::vector< ::dsn::replication::replica_info> & val) {
  this->gc_replicas = val;
__isset.gc_replicas = true;
}

uint32_t configuration_query_by_node_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->partitions.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->partitions[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gc_replicas.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->gc_replicas.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->gc_replicas[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gc_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<configuration_update_request> ::const_iterator _iter50;
    for (_iter50 = this->partitions.begin(); _iter50 != this->partitions.end(); ++_iter50)
    {
      xfer += (*_iter50).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gc_replicas) {
    xfer += oprot->writeFieldBegin("gc_replicas", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gc_replicas.size()));
      std::vector< ::dsn::replication::replica_info> ::const_iterator _iter51;
      for (_iter51 = this->gc_replicas.begin(); _iter51 != this->gc_replicas.end(); ++_iter51)
      {
        xfer += (*_iter51).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partitions, b.partitions);
  swap(a.gc_replicas, b.gc_replicas);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_response::configuration_query_by_node_response(const configuration_query_by_node_response& other52) {
  err = other52.err;
  partitions = other52.partitions;
  gc_replicas = other52.gc_replicas;
  __isset = other52.__isset;
}
configuration_query_by_node_response& configuration_query_by_node_response::operator=(const configuration_query_by_node_response& other53) {
  err = other53.err;
  partitions = other53.partitions;
  gc_replicas = other53.gc_replicas;
  __isset = other53.__isset;
  return *this;
}
void configuration_query_by_node_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_response(";
  out << "err=" << to_string(err);
  out << ", " << "partitions=" << to_string(partitions);
  out << ", " << "gc_replicas="; (__isset.gc_replicas ? (out << to_string(gc_replicas)) : (out << "<null>"));
  out << ")";
}


configuration_recovery_request::~configuration_recovery_request() throw() {
}


void configuration_recovery_request::__set_recovery_set(const std::vector< ::dsn::rpc_address> & val) {
  this->recovery_set = val;
}

void configuration_recovery_request::__set_skip_bad_nodes(const bool val) {
  this->skip_bad_nodes = val;
}

void configuration_recovery_request::__set_skip_lost_partitions(const bool val) {
  this->skip_lost_partitions = val;
}

uint32_t configuration_recovery_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recovery_set.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->recovery_set.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->recovery_set[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.recovery_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_bad_nodes);
          this->__isset.skip_bad_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_lost_partitions);
          this->__isset.skip_lost_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recovery_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recovery_request");

  xfer += oprot->writeFieldBegin("recovery_set", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->recovery_set.size()));
    std::vector< ::dsn::rpc_address> ::const_iterator _iter59;
    for (_iter59 = this->recovery_set.begin(); _iter59 != this->recovery_set.end(); ++_iter59)
    {
      xfer += (*_iter59).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_bad_nodes", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->skip_bad_nodes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_lost_partitions", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->skip_lost_partitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recovery_request &a, configuration_recovery_request &b) {
  using ::std::swap;
  swap(a.recovery_set, b.recovery_set);
  swap(a.skip_bad_nodes, b.skip_bad_nodes);
  swap(a.skip_lost_partitions, b.skip_lost_partitions);
  swap(a.__isset, b.__isset);
}

configuration_recovery_request::configuration_recovery_request(const configuration_recovery_request& other60) {
  recovery_set = other60.recovery_set;
  skip_bad_nodes = other60.skip_bad_nodes;
  skip_lost_partitions = other60.skip_lost_partitions;
  __isset = other60.__isset;
}
configuration_recovery_request& configuration_recovery_request::operator=(const configuration_recovery_request& other61) {
  recovery_set = other61.recovery_set;
  skip_bad_nodes = other61.skip_bad_nodes;
  skip_lost_partitions = other61.skip_lost_partitions;
  __isset = other61.__isset;
  return *this;
}
void configuration_recovery_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recovery_request(";
  out << "recovery_set=" << to_string(recovery_set);
  out << ", " << "skip_bad_nodes=" << to_string(skip_bad_nodes);
  out << ", " << "skip_lost_partitions=" << to_string(skip_lost_partitions);
  out << ")";
}


configuration_recovery_response::~configuration_recovery_response() throw() {
}


void configuration_recovery_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_recovery_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_recovery_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recovery_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recovery_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recovery_response &a, configuration_recovery_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_recovery_response::configuration_recovery_response(const configuration_recovery_response& other62) {
  err = other62.err;
  hint_message = other62.hint_message;
  __isset = other62.__isset;
}
configuration_recovery_response& configuration_recovery_response::operator=(const configuration_recovery_response& other63) {
  err = other63.err;
  hint_message = other63.hint_message;
  __isset = other63.__isset;
  return *this;
}
void configuration_recovery_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recovery_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


create_app_options::~create_app_options() throw() {
}


void create_app_options::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

void create_app_options::__set_replica_count(const int32_t val) {
  this->replica_count = val;
}

void create_app_options::__set_success_if_exist(const bool val) {
  this->success_if_exist = val;
}

void create_app_options::__set_app_type(const std::string& val) {
  this->app_type = val;
}

void create_app_options::__set_is_stateful(const bool val) {
  this->is_stateful = val;
}

void create_app_options::__set_envs(const std::map<std::string, std::string> & val) {
  this->envs = val;
}

uint32_t create_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replica_count);
          this->__isset.replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_exist);
          this->__isset.success_if_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_stateful);
          this->__isset.is_stateful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->envs.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::string& _val70 = this->envs[_key69];
              xfer += iprot->readString(_val70);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.envs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_app_options");

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success_if_exist", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->success_if_exist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_stateful", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_stateful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("envs", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->envs.size()));
    std::map<std::string, std::string> ::const_iterator _iter71;
    for (_iter71 = this->envs.begin(); _iter71 != this->envs.end(); ++_iter71)
    {
      xfer += oprot->writeString(_iter71->first);
      xfer += oprot->writeString(_iter71->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_app_options &a, create_app_options &b) {
  using ::std::swap;
  swap(a.partition_count, b.partition_count);
  swap(a.replica_count, b.replica_count);
  swap(a.success_if_exist, b.success_if_exist);
  swap(a.app_type, b.app_type);
  swap(a.is_stateful, b.is_stateful);
  swap(a.envs, b.envs);
  swap(a.__isset, b.__isset);
}

create_app_options::create_app_options(const create_app_options& other72) {
  partition_count = other72.partition_count;
  replica_count = other72.replica_count;
  success_if_exist = other72.success_if_exist;
  app_type = other72.app_type;
  is_stateful = other72.is_stateful;
  envs = other72.envs;
  __isset = other72.__isset;
}
create_app_options& create_app_options::operator=(const create_app_options& other73) {
  partition_count = other73.partition_count;
  replica_count = other73.replica_count;
  success_if_exist = other73.success_if_exist;
  app_type = other73.app_type;
  is_stateful = other73.is_stateful;
  envs = other73.envs;
  __isset = other73.__isset;
  return *this;
}
void create_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_app_options(";
  out << "partition_count=" << to_string(partition_count);
  out << ", " << "replica_count=" << to_string(replica_count);
  out << ", " << "success_if_exist=" << to_string(success_if_exist);
  out << ", " << "app_type=" << to_string(app_type);
  out << ", " << "is_stateful=" << to_string(is_stateful);
  out << ", " << "envs=" << to_string(envs);
  out << ")";
}


configuration_create_app_request::~configuration_create_app_request() throw() {
}


void configuration_create_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_create_app_request::__set_options(const create_app_options& val) {
  this->options = val;
}

uint32_t configuration_create_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_request &a, configuration_create_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_create_app_request::configuration_create_app_request(const configuration_create_app_request& other74) {
  app_name = other74.app_name;
  options = other74.options;
  __isset = other74.__isset;
}
configuration_create_app_request& configuration_create_app_request::operator=(const configuration_create_app_request& other75) {
  app_name = other75.app_name;
  options = other75.options;
  __isset = other75.__isset;
  return *this;
}
void configuration_create_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


configuration_create_app_response::~configuration_create_app_response() throw() {
}


void configuration_create_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_create_app_response::__set_appid(const int32_t val) {
  this->appid = val;
}

uint32_t configuration_create_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_response &a, configuration_create_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.__isset, b.__isset);
}

configuration_create_app_response::configuration_create_app_response(const configuration_create_app_response& other76) {
  err = other76.err;
  appid = other76.appid;
  __isset = other76.__isset;
}
configuration_create_app_response& configuration_create_app_response::operator=(const configuration_create_app_response& other77) {
  err = other77.err;
  appid = other77.appid;
  __isset = other77.__isset;
  return *this;
}
void configuration_create_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ")";
}


drop_app_options::~drop_app_options() throw() {
}


void drop_app_options::__set_success_if_not_exist(const bool val) {
  this->success_if_not_exist = val;
}

void drop_app_options::__set_reserve_seconds(const int64_t val) {
  this->reserve_seconds = val;
__isset.reserve_seconds = true;
}

uint32_t drop_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_not_exist);
          this->__isset.success_if_not_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reserve_seconds);
          this->__isset.reserve_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t drop_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("drop_app_options");

  xfer += oprot->writeFieldBegin("success_if_not_exist", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success_if_not_exist);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.reserve_seconds) {
    xfer += oprot->writeFieldBegin("reserve_seconds", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->reserve_seconds);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(drop_app_options &a, drop_app_options &b) {
  using ::std::swap;
  swap(a.success_if_not_exist, b.success_if_not_exist);
  swap(a.reserve_seconds, b.reserve_seconds);
  swap(a.__isset, b.__isset);
}

drop_app_options::drop_app_options(const drop_app_options& other78) {
  success_if_not_exist = other78.success_if_not_exist;
  reserve_seconds = other78.reserve_seconds;
  __isset = other78.__isset;
}
drop_app_options& drop_app_options::operator=(const drop_app_options& other79) {
  success_if_not_exist = other79.success_if_not_exist;
  reserve_seconds = other79.reserve_seconds;
  __isset = other79.__isset;
  return *this;
}
void drop_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "drop_app_options(";
  out << "success_if_not_exist=" << to_string(success_if_not_exist);
  out << ", " << "reserve_seconds="; (__isset.reserve_seconds ? (out << to_string(reserve_seconds)) : (out << "<null>"));
  out << ")";
}


configuration_drop_app_request::~configuration_drop_app_request() throw() {
}


void configuration_drop_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_drop_app_request::__set_options(const drop_app_options& val) {
  this->options = val;
}

uint32_t configuration_drop_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_request::configuration_drop_app_request(const configuration_drop_app_request& other80) {
  app_name = other80.app_name;
  options = other80.options;
  __isset = other80.__isset;
}
configuration_drop_app_request& configuration_drop_app_request::operator=(const configuration_drop_app_request& other81) {
  app_name = other81.app_name;
  options = other81.options;
  __isset = other81.__isset;
  return *this;
}
void configuration_drop_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


configuration_drop_app_response::~configuration_drop_app_response() throw() {
}


void configuration_drop_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_drop_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_response::configuration_drop_app_response(const configuration_drop_app_response& other82) {
  err = other82.err;
  __isset = other82.__isset;
}
configuration_drop_app_response& configuration_drop_app_response::operator=(const configuration_drop_app_response& other83) {
  err = other83.err;
  __isset = other83.__isset;
  return *this;
}
void configuration_drop_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_response(";
  out << "err=" << to_string(err);
  out << ")";
}


configuration_rename_app_request::~configuration_rename_app_request() throw() {
}


void configuration_rename_app_request::__set_old_app_name(const std::string& val) {
  this->old_app_name = val;
}

void configuration_rename_app_request::__set_new_app_name(const std::string& val) {
  this->new_app_name = val;
}

uint32_t configuration_rename_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->old_app_name);
          this->__isset.old_app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_app_name);
          this->__isset.new_app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_rename_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_rename_app_request");

  xfer += oprot->writeFieldBegin("old_app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->old_app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->new_app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_rename_app_request &a, configuration_rename_app_request &b) {
  using ::std::swap;
  swap(a.old_app_name, b.old_app_name);
  swap(a.new_app_name, b.new_app_name);
  swap(a.__isset, b.__isset);
}

configuration_rename_app_request::configuration_rename_app_request(const configuration_rename_app_request& other84) {
  old_app_name = other84.old_app_name;
  new_app_name = other84.new_app_name;
  __isset = other84.__isset;
}
configuration_rename_app_request& configuration_rename_app_request::operator=(const configuration_rename_app_request& other85) {
  old_app_name = other85.old_app_name;
  new_app_name = other85.new_app_name;
  __isset = other85.__isset;
  return *this;
}
void configuration_rename_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_rename_app_request(";
  out << "old_app_name=" << to_string(old_app_name);
  out << ", " << "new_app_name=" << to_string(new_app_name);
  out << ")";
}


configuration_rename_app_response::~configuration_rename_app_response() throw() {
}


void configuration_rename_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_rename_app_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_rename_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_rename_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_rename_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_rename_app_response &a, configuration_rename_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_rename_app_response::configuration_rename_app_response(const configuration_rename_app_response& other86) {
  err = other86.err;
  hint_message = other86.hint_message;
  __isset = other86.__isset;
}
configuration_rename_app_response& configuration_rename_app_response::operator=(const configuration_rename_app_response& other87) {
  err = other87.err;
  hint_message = other87.hint_message;
  __isset = other87.__isset;
  return *this;
}
void configuration_rename_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_rename_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


configuration_recall_app_request::~configuration_recall_app_request() throw() {
}


void configuration_recall_app_request::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void configuration_recall_app_request::__set_new_app_name(const std::string& val) {
  this->new_app_name = val;
}

uint32_t configuration_recall_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_app_name);
          this->__isset.new_app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recall_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recall_app_request");

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->new_app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recall_app_request &a, configuration_recall_app_request &b) {
  using ::std::swap;
  swap(a.app_id, b.app_id);
  swap(a.new_app_name, b.new_app_name);
  swap(a.__isset, b.__isset);
}

configuration_recall_app_request::configuration_recall_app_request(const configuration_recall_app_request& other88) {
  app_id = other88.app_id;
  new_app_name = other88.new_app_name;
  __isset = other88.__isset;
}
configuration_recall_app_request& configuration_recall_app_request::operator=(const configuration_recall_app_request& other89) {
  app_id = other89.app_id;
  new_app_name = other89.new_app_name;
  __isset = other89.__isset;
  return *this;
}
void configuration_recall_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recall_app_request(";
  out << "app_id=" << to_string(app_id);
  out << ", " << "new_app_name=" << to_string(new_app_name);
  out << ")";
}


configuration_recall_app_response::~configuration_recall_app_response() throw() {
}


void configuration_recall_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_recall_app_response::__set_info(const  ::dsn::app_info& val) {
  this->info = val;
}

uint32_t configuration_recall_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_recall_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_recall_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_recall_app_response &a, configuration_recall_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.info, b.info);
  swap(a.__isset, b.__isset);
}

configuration_recall_app_response::configuration_recall_app_response(const configuration_recall_app_response& other90) {
  err = other90.err;
  info = other90.info;
  __isset = other90.__isset;
}
configuration_recall_app_response& configuration_recall_app_response::operator=(const configuration_recall_app_response& other91) {
  err = other91.err;
  info = other91.info;
  __isset = other91.__isset;
  return *this;
}
void configuration_recall_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_recall_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "info=" << to_string(info);
  out << ")";
}


configuration_list_apps_request::~configuration_list_apps_request() throw() {
}


void configuration_list_apps_request::__set_status(const  ::dsn::app_status::type val) {
  this->status = val;
}

uint32_t configuration_list_apps_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast92;
          xfer += iprot->readI32(ecast92);
          this->status = ( ::dsn::app_status::type)ecast92;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_request::configuration_list_apps_request(const configuration_list_apps_request& other93) {
  status = other93.status;
  __isset = other93.__isset;
}
configuration_list_apps_request& configuration_list_apps_request::operator=(const configuration_list_apps_request& other94) {
  status = other94.status;
  __isset = other94.__isset;
  return *this;
}
void configuration_list_apps_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_list_apps_response::~configuration_list_apps_response() throw() {
}


void configuration_list_apps_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_apps_response::__set_infos(const std::vector< ::dsn::app_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_apps_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->infos.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->infos[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector< ::dsn::app_info> ::const_iterator _iter100;
    for (_iter100 = this->infos.begin(); _iter100 != this->infos.end(); ++_iter100)
    {
      xfer += (*_iter100).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_response::configuration_list_apps_response(const configuration_list_apps_response& other101) {
  err = other101.err;
  infos = other101.infos;
  __isset = other101.__isset;
}
configuration_list_apps_response& configuration_list_apps_response::operator=(const configuration_list_apps_response& other102) {
  err = other102.err;
  infos = other102.infos;
  __isset = other102.__isset;
  return *this;
}
void configuration_list_apps_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


query_app_info_request::~query_app_info_request() throw() {
}


void query_app_info_request::__set_meta_server(const  ::dsn::rpc_address& val) {
  this->meta_server = val;
}

uint32_t query_app_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta_server.read(iprot);
          this->__isset.meta_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_info_request");

  xfer += oprot->writeFieldBegin("meta_server", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->meta_server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_info_request &a, query_app_info_request &b) {
  using ::std::swap;
  swap(a.meta_server, b.meta_server);
  swap(a.__isset, b.__isset);
}

query_app_info_request::query_app_info_request(const query_app_info_request& other103) {
  meta_server = other103.meta_server;
  __isset = other103.__isset;
}
query_app_info_request& query_app_info_request::operator=(const query_app_info_request& other104) {
  meta_server = other104.meta_server;
  __isset = other104.__isset;
  return *this;
}
void query_app_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_info_request(";
  out << "meta_server=" << to_string(meta_server);
  out << ")";
}


query_app_info_response::~query_app_info_response() throw() {
}


void query_app_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_app_info_response::__set_apps(const std::vector< ::dsn::app_info> & val) {
  this->apps = val;
}

uint32_t query_app_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->apps.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->apps.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += this->apps[_i109].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.apps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("apps", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->apps.size()));
    std::vector< ::dsn::app_info> ::const_iterator _iter110;
    for (_iter110 = this->apps.begin(); _iter110 != this->apps.end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_info_response &a, query_app_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.apps, b.apps);
  swap(a.__isset, b.__isset);
}

query_app_info_response::query_app_info_response(const query_app_info_response& other111) {
  err = other111.err;
  apps = other111.apps;
  __isset = other111.__isset;
}
query_app_info_response& query_app_info_response::operator=(const query_app_info_response& other112) {
  err = other112.err;
  apps = other112.apps;
  __isset = other112.__isset;
  return *this;
}
void query_app_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "apps=" << to_string(apps);
  out << ")";
}


configuration_update_app_env_request::~configuration_update_app_env_request() throw() {
}


void configuration_update_app_env_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_update_app_env_request::__set_op(const app_env_operation::type val) {
  this->op = val;
}

void configuration_update_app_env_request::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
__isset.keys = true;
}

void configuration_update_app_env_request::__set_values(const std::vector<std::string> & val) {
  this->values = val;
__isset.values = true;
}

void configuration_update_app_env_request::__set_clear_prefix(const std::string& val) {
  this->clear_prefix = val;
__isset.clear_prefix = true;
}

uint32_t configuration_update_app_env_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast113;
          xfer += iprot->readI32(ecast113);
          this->op = (app_env_operation::type)ecast113;
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->keys.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += iprot->readString(this->keys[_i118]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->values.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readString(this->values[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clear_prefix);
          this->__isset.clear_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_app_env_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_app_env_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.keys) {
    xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
      std::vector<std::string> ::const_iterator _iter124;
      for (_iter124 = this->keys.begin(); _iter124 != this->keys.end(); ++_iter124)
      {
        xfer += oprot->writeString((*_iter124));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.values) {
    xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
      std::vector<std::string> ::const_iterator _iter125;
      for (_iter125 = this->values.begin(); _iter125 != this->values.end(); ++_iter125)
      {
        xfer += oprot->writeString((*_iter125));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clear_prefix) {
    xfer += oprot->writeFieldBegin("clear_prefix", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clear_prefix);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_app_env_request &a, configuration_update_app_env_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.op, b.op);
  swap(a.keys, b.keys);
  swap(a.values, b.values);
  swap(a.clear_prefix, b.clear_prefix);
  swap(a.__isset, b.__isset);
}

configuration_update_app_env_request::configuration_update_app_env_request(const configuration_update_app_env_request& other126) {
  app_name = other126.app_name;
  op = other126.op;
  keys = other126.keys;
  values = other126.values;
  clear_prefix = other126.clear_prefix;
  __isset = other126.__isset;
}
configuration_update_app_env_request& configuration_update_app_env_request::operator=(const configuration_update_app_env_request& other127) {
  app_name = other127.app_name;
  op = other127.op;
  keys = other127.keys;
  values = other127.values;
  clear_prefix = other127.clear_prefix;
  __isset = other127.__isset;
  return *this;
}
void configuration_update_app_env_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_app_env_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "op=" << to_string(op);
  out << ", " << "keys="; (__isset.keys ? (out << to_string(keys)) : (out << "<null>"));
  out << ", " << "values="; (__isset.values ? (out << to_string(values)) : (out << "<null>"));
  out << ", " << "clear_prefix="; (__isset.clear_prefix ? (out << to_string(clear_prefix)) : (out << "<null>"));
  out << ")";
}


configuration_update_app_env_response::~configuration_update_app_env_response() throw() {
}


void configuration_update_app_env_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_update_app_env_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_update_app_env_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_app_env_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_app_env_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_app_env_response &a, configuration_update_app_env_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_update_app_env_response::configuration_update_app_env_response(const configuration_update_app_env_response& other128) {
  err = other128.err;
  hint_message = other128.hint_message;
  __isset = other128.__isset;
}
configuration_update_app_env_response& configuration_update_app_env_response::operator=(const configuration_update_app_env_response& other129) {
  err = other129.err;
  hint_message = other129.hint_message;
  __isset = other129.__isset;
  return *this;
}
void configuration_update_app_env_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_app_env_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


start_app_manual_compact_request::~start_app_manual_compact_request() throw() {
}


void start_app_manual_compact_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void start_app_manual_compact_request::__set_trigger_time(const int64_t val) {
  this->trigger_time = val;
__isset.trigger_time = true;
}

void start_app_manual_compact_request::__set_target_level(const int32_t val) {
  this->target_level = val;
__isset.target_level = true;
}

void start_app_manual_compact_request::__set_bottommost(const bool val) {
  this->bottommost = val;
__isset.bottommost = true;
}

void start_app_manual_compact_request::__set_max_running_count(const int32_t val) {
  this->max_running_count = val;
__isset.max_running_count = true;
}

uint32_t start_app_manual_compact_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->trigger_time);
          this->__isset.trigger_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target_level);
          this->__isset.target_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bottommost);
          this->__isset.bottommost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_running_count);
          this->__isset.max_running_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_app_manual_compact_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_app_manual_compact_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.trigger_time) {
    xfer += oprot->writeFieldBegin("trigger_time", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->trigger_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.target_level) {
    xfer += oprot->writeFieldBegin("target_level", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->target_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bottommost) {
    xfer += oprot->writeFieldBegin("bottommost", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->bottommost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_running_count) {
    xfer += oprot->writeFieldBegin("max_running_count", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->max_running_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_app_manual_compact_request &a, start_app_manual_compact_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.trigger_time, b.trigger_time);
  swap(a.target_level, b.target_level);
  swap(a.bottommost, b.bottommost);
  swap(a.max_running_count, b.max_running_count);
  swap(a.__isset, b.__isset);
}

start_app_manual_compact_request::start_app_manual_compact_request(const start_app_manual_compact_request& other130) {
  app_name = other130.app_name;
  trigger_time = other130.trigger_time;
  target_level = other130.target_level;
  bottommost = other130.bottommost;
  max_running_count = other130.max_running_count;
  __isset = other130.__isset;
}
start_app_manual_compact_request& start_app_manual_compact_request::operator=(const start_app_manual_compact_request& other131) {
  app_name = other131.app_name;
  trigger_time = other131.trigger_time;
  target_level = other131.target_level;
  bottommost = other131.bottommost;
  max_running_count = other131.max_running_count;
  __isset = other131.__isset;
  return *this;
}
void start_app_manual_compact_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_app_manual_compact_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "trigger_time="; (__isset.trigger_time ? (out << to_string(trigger_time)) : (out << "<null>"));
  out << ", " << "target_level="; (__isset.target_level ? (out << to_string(target_level)) : (out << "<null>"));
  out << ", " << "bottommost="; (__isset.bottommost ? (out << to_string(bottommost)) : (out << "<null>"));
  out << ", " << "max_running_count="; (__isset.max_running_count ? (out << to_string(max_running_count)) : (out << "<null>"));
  out << ")";
}


start_app_manual_compact_response::~start_app_manual_compact_response() throw() {
}


void start_app_manual_compact_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void start_app_manual_compact_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
}

uint32_t start_app_manual_compact_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_app_manual_compact_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_app_manual_compact_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_app_manual_compact_response &a, start_app_manual_compact_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

start_app_manual_compact_response::start_app_manual_compact_response(const start_app_manual_compact_response& other132) {
  err = other132.err;
  hint_msg = other132.hint_msg;
  __isset = other132.__isset;
}
start_app_manual_compact_response& start_app_manual_compact_response::operator=(const start_app_manual_compact_response& other133) {
  err = other133.err;
  hint_msg = other133.hint_msg;
  __isset = other133.__isset;
  return *this;
}
void start_app_manual_compact_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_app_manual_compact_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg=" << to_string(hint_msg);
  out << ")";
}


query_app_manual_compact_request::~query_app_manual_compact_request() throw() {
}


void query_app_manual_compact_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t query_app_manual_compact_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_manual_compact_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_manual_compact_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_manual_compact_request &a, query_app_manual_compact_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

query_app_manual_compact_request::query_app_manual_compact_request(const query_app_manual_compact_request& other134) {
  app_name = other134.app_name;
  __isset = other134.__isset;
}
query_app_manual_compact_request& query_app_manual_compact_request::operator=(const query_app_manual_compact_request& other135) {
  app_name = other135.app_name;
  __isset = other135.__isset;
  return *this;
}
void query_app_manual_compact_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_manual_compact_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


query_app_manual_compact_response::~query_app_manual_compact_response() throw() {
}


void query_app_manual_compact_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_app_manual_compact_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
}

void query_app_manual_compact_response::__set_progress(const int32_t val) {
  this->progress = val;
__isset.progress = true;
}

uint32_t query_app_manual_compact_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_app_manual_compact_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_app_manual_compact_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_msg);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_app_manual_compact_response &a, query_app_manual_compact_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.progress, b.progress);
  swap(a.__isset, b.__isset);
}

query_app_manual_compact_response::query_app_manual_compact_response(const query_app_manual_compact_response& other136) {
  err = other136.err;
  hint_msg = other136.hint_msg;
  progress = other136.progress;
  __isset = other136.__isset;
}
query_app_manual_compact_response& query_app_manual_compact_response::operator=(const query_app_manual_compact_response& other137) {
  err = other137.err;
  hint_msg = other137.hint_msg;
  progress = other137.progress;
  __isset = other137.__isset;
  return *this;
}
void query_app_manual_compact_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_app_manual_compact_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg=" << to_string(hint_msg);
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ")";
}


node_info::~node_info() throw() {
}


void node_info::__set_status(const node_status::type val) {
  this->status = val;
}

void node_info::__set_address(const  ::dsn::rpc_address& val) {
  this->address = val;
}

uint32_t node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast138;
          xfer += iprot->readI32(ecast138);
          this->status = (node_status::type)ecast138;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_info");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_info &a, node_info &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.address, b.address);
  swap(a.__isset, b.__isset);
}

node_info::node_info(const node_info& other139) {
  status = other139.status;
  address = other139.address;
  __isset = other139.__isset;
}
node_info& node_info::operator=(const node_info& other140) {
  status = other140.status;
  address = other140.address;
  __isset = other140.__isset;
  return *this;
}
void node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_info(";
  out << "status=" << to_string(status);
  out << ", " << "address=" << to_string(address);
  out << ")";
}


configuration_list_nodes_request::~configuration_list_nodes_request() throw() {
}


void configuration_list_nodes_request::__set_status(const node_status::type val) {
  this->status = val;
}

uint32_t configuration_list_nodes_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast141;
          xfer += iprot->readI32(ecast141);
          this->status = (node_status::type)ecast141;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_request::configuration_list_nodes_request(const configuration_list_nodes_request& other142) {
  status = other142.status;
  __isset = other142.__isset;
}
configuration_list_nodes_request& configuration_list_nodes_request::operator=(const configuration_list_nodes_request& other143) {
  status = other143.status;
  __isset = other143.__isset;
  return *this;
}
void configuration_list_nodes_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_list_nodes_response::~configuration_list_nodes_response() throw() {
}


void configuration_list_nodes_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_nodes_response::__set_infos(const std::vector<node_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_nodes_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->infos.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += this->infos[_i148].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector<node_info> ::const_iterator _iter149;
    for (_iter149 = this->infos.begin(); _iter149 != this->infos.end(); ++_iter149)
    {
      xfer += (*_iter149).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_response::configuration_list_nodes_response(const configuration_list_nodes_response& other150) {
  err = other150.err;
  infos = other150.infos;
  __isset = other150.__isset;
}
configuration_list_nodes_response& configuration_list_nodes_response::operator=(const configuration_list_nodes_response& other151) {
  err = other151.err;
  infos = other151.infos;
  __isset = other151.__isset;
  return *this;
}
void configuration_list_nodes_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


configuration_cluster_info_request::~configuration_cluster_info_request() throw() {
}


uint32_t configuration_cluster_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_cluster_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_cluster_info_request");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_cluster_info_request &a, configuration_cluster_info_request &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

configuration_cluster_info_request::configuration_cluster_info_request(const configuration_cluster_info_request& other152) {
  (void) other152;
}
configuration_cluster_info_request& configuration_cluster_info_request::operator=(const configuration_cluster_info_request& other153) {
  (void) other153;
  return *this;
}
void configuration_cluster_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_cluster_info_request(";
  out << ")";
}


configuration_cluster_info_response::~configuration_cluster_info_response() throw() {
}


void configuration_cluster_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_cluster_info_response::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
}

void configuration_cluster_info_response::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

uint32_t configuration_cluster_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->keys.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += iprot->readString(this->keys[_i158]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _etype162;
            xfer += iprot->readListBegin(_etype162, _size159);
            this->values.resize(_size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              xfer += iprot->readString(this->values[_i163]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_cluster_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_cluster_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
    std::vector<std::string> ::const_iterator _iter164;
    for (_iter164 = this->keys.begin(); _iter164 != this->keys.end(); ++_iter164)
    {
      xfer += oprot->writeString((*_iter164));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter165;
    for (_iter165 = this->values.begin(); _iter165 != this->values.end(); ++_iter165)
    {
      xfer += oprot->writeString((*_iter165));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_cluster_info_response &a, configuration_cluster_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.keys, b.keys);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

configuration_cluster_info_response::configuration_cluster_info_response(const configuration_cluster_info_response& other166) {
  err = other166.err;
  keys = other166.keys;
  values = other166.values;
  __isset = other166.__isset;
}
configuration_cluster_info_response& configuration_cluster_info_response::operator=(const configuration_cluster_info_response& other167) {
  err = other167.err;
  keys = other167.keys;
  values = other167.values;
  __isset = other167.__isset;
  return *this;
}
void configuration_cluster_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_cluster_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "keys=" << to_string(keys);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


configuration_meta_control_request::~configuration_meta_control_request() throw() {
}


void configuration_meta_control_request::__set_level(const meta_function_level::type val) {
  this->level = val;
}

uint32_t configuration_meta_control_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast168;
          xfer += iprot->readI32(ecast168);
          this->level = (meta_function_level::type)ecast168;
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_meta_control_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_meta_control_request");

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_meta_control_request &a, configuration_meta_control_request &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.__isset, b.__isset);
}

configuration_meta_control_request::configuration_meta_control_request(const configuration_meta_control_request& other169) {
  level = other169.level;
  __isset = other169.__isset;
}
configuration_meta_control_request& configuration_meta_control_request::operator=(const configuration_meta_control_request& other170) {
  level = other170.level;
  __isset = other170.__isset;
  return *this;
}
void configuration_meta_control_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_meta_control_request(";
  out << "level=" << to_string(level);
  out << ")";
}


configuration_meta_control_response::~configuration_meta_control_response() throw() {
}


void configuration_meta_control_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_meta_control_response::__set_old_level(const meta_function_level::type val) {
  this->old_level = val;
}

uint32_t configuration_meta_control_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->old_level = (meta_function_level::type)ecast171;
          this->__isset.old_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_meta_control_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_meta_control_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("old_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->old_level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_meta_control_response &a, configuration_meta_control_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.old_level, b.old_level);
  swap(a.__isset, b.__isset);
}

configuration_meta_control_response::configuration_meta_control_response(const configuration_meta_control_response& other172) {
  err = other172.err;
  old_level = other172.old_level;
  __isset = other172.__isset;
}
configuration_meta_control_response& configuration_meta_control_response::operator=(const configuration_meta_control_response& other173) {
  err = other173.err;
  old_level = other173.old_level;
  __isset = other173.__isset;
  return *this;
}
void configuration_meta_control_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_meta_control_response(";
  out << "err=" << to_string(err);
  out << ", " << "old_level=" << to_string(old_level);
  out << ")";
}


configuration_proposal_action::~configuration_proposal_action() throw() {
}


void configuration_proposal_action::__set_target(const  ::dsn::rpc_address& val) {
  this->target = val;
}

void configuration_proposal_action::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_proposal_action::__set_type(const config_type::type val) {
  this->type = val;
}

uint32_t configuration_proposal_action::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast174;
          xfer += iprot->readI32(ecast174);
          this->type = (config_type::type)ecast174;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_proposal_action::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_proposal_action");

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_proposal_action &a, configuration_proposal_action &b) {
  using ::std::swap;
  swap(a.target, b.target);
  swap(a.node, b.node);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

configuration_proposal_action::configuration_proposal_action(const configuration_proposal_action& other175) {
  target = other175.target;
  node = other175.node;
  type = other175.type;
  __isset = other175.__isset;
}
configuration_proposal_action& configuration_proposal_action::operator=(const configuration_proposal_action& other176) {
  target = other176.target;
  node = other176.node;
  type = other176.type;
  __isset = other176.__isset;
  return *this;
}
void configuration_proposal_action::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_proposal_action(";
  out << "target=" << to_string(target);
  out << ", " << "node=" << to_string(node);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


configuration_balancer_request::~configuration_balancer_request() throw() {
}


void configuration_balancer_request::__set_gpid(const  ::dsn::gpid& val) {
  this->gpid = val;
}

void configuration_balancer_request::__set_action_list(const std::vector<configuration_proposal_action> & val) {
  this->action_list = val;
}

void configuration_balancer_request::__set_force(const bool val) {
  this->force = val;
__isset.force = true;
}

void configuration_balancer_request::__set_balance_type(const balancer_request_type::type val) {
  this->balance_type = val;
__isset.balance_type = true;
}

uint32_t configuration_balancer_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->action_list.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->action_list.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->action_list[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.action_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->force);
          this->__isset.force = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast182;
          xfer += iprot->readI32(ecast182);
          this->balance_type = (balancer_request_type::type)ecast182;
          this->__isset.balance_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_balancer_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_balancer_request");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->action_list.size()));
    std::vector<configuration_proposal_action> ::const_iterator _iter183;
    for (_iter183 = this->action_list.begin(); _iter183 != this->action_list.end(); ++_iter183)
    {
      xfer += (*_iter183).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.force) {
    xfer += oprot->writeFieldBegin("force", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->force);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.balance_type) {
    xfer += oprot->writeFieldBegin("balance_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->balance_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_balancer_request &a, configuration_balancer_request &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.action_list, b.action_list);
  swap(a.force, b.force);
  swap(a.balance_type, b.balance_type);
  swap(a.__isset, b.__isset);
}

configuration_balancer_request::configuration_balancer_request(const configuration_balancer_request& other184) {
  gpid = other184.gpid;
  action_list = other184.action_list;
  force = other184.force;
  balance_type = other184.balance_type;
  __isset = other184.__isset;
}
configuration_balancer_request& configuration_balancer_request::operator=(const configuration_balancer_request& other185) {
  gpid = other185.gpid;
  action_list = other185.action_list;
  force = other185.force;
  balance_type = other185.balance_type;
  __isset = other185.__isset;
  return *this;
}
void configuration_balancer_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_balancer_request(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "action_list=" << to_string(action_list);
  out << ", " << "force="; (__isset.force ? (out << to_string(force)) : (out << "<null>"));
  out << ", " << "balance_type="; (__isset.balance_type ? (out << to_string(balance_type)) : (out << "<null>"));
  out << ")";
}


configuration_balancer_response::~configuration_balancer_response() throw() {
}


void configuration_balancer_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_balancer_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_balancer_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_balancer_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_balancer_response &a, configuration_balancer_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_balancer_response::configuration_balancer_response(const configuration_balancer_response& other186) {
  err = other186.err;
  __isset = other186.__isset;
}
configuration_balancer_response& configuration_balancer_response::operator=(const configuration_balancer_response& other187) {
  err = other187.err;
  __isset = other187.__isset;
  return *this;
}
void configuration_balancer_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_balancer_response(";
  out << "err=" << to_string(err);
  out << ")";
}


ddd_diagnose_request::~ddd_diagnose_request() throw() {
}


void ddd_diagnose_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

uint32_t ddd_diagnose_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_diagnose_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_diagnose_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_diagnose_request &a, ddd_diagnose_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.__isset, b.__isset);
}

ddd_diagnose_request::ddd_diagnose_request(const ddd_diagnose_request& other188) {
  pid = other188.pid;
  __isset = other188.__isset;
}
ddd_diagnose_request& ddd_diagnose_request::operator=(const ddd_diagnose_request& other189) {
  pid = other189.pid;
  __isset = other189.__isset;
  return *this;
}
void ddd_diagnose_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_diagnose_request(";
  out << "pid=" << to_string(pid);
  out << ")";
}


ddd_node_info::~ddd_node_info() throw() {
}


void ddd_node_info::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void ddd_node_info::__set_drop_time_ms(const int64_t val) {
  this->drop_time_ms = val;
}

void ddd_node_info::__set_is_alive(const bool val) {
  this->is_alive = val;
}

void ddd_node_info::__set_is_collected(const bool val) {
  this->is_collected = val;
}

void ddd_node_info::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void ddd_node_info::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void ddd_node_info::__set_last_prepared_decree(const int64_t val) {
  this->last_prepared_decree = val;
}

uint32_t ddd_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->drop_time_ms);
          this->__isset.drop_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_alive);
          this->__isset.is_alive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_collected);
          this->__isset.is_collected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_prepared_decree);
          this->__isset.last_prepared_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_node_info");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->drop_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_alive", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_alive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_collected", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_collected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_prepared_decree", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->last_prepared_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_node_info &a, ddd_node_info &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.drop_time_ms, b.drop_time_ms);
  swap(a.is_alive, b.is_alive);
  swap(a.is_collected, b.is_collected);
  swap(a.ballot, b.ballot);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.last_prepared_decree, b.last_prepared_decree);
  swap(a.__isset, b.__isset);
}

ddd_node_info::ddd_node_info(const ddd_node_info& other190) {
  node = other190.node;
  drop_time_ms = other190.drop_time_ms;
  is_alive = other190.is_alive;
  is_collected = other190.is_collected;
  ballot = other190.ballot;
  last_committed_decree = other190.last_committed_decree;
  last_prepared_decree = other190.last_prepared_decree;
  __isset = other190.__isset;
}
ddd_node_info& ddd_node_info::operator=(const ddd_node_info& other191) {
  node = other191.node;
  drop_time_ms = other191.drop_time_ms;
  is_alive = other191.is_alive;
  is_collected = other191.is_collected;
  ballot = other191.ballot;
  last_committed_decree = other191.last_committed_decree;
  last_prepared_decree = other191.last_prepared_decree;
  __isset = other191.__isset;
  return *this;
}
void ddd_node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_node_info(";
  out << "node=" << to_string(node);
  out << ", " << "drop_time_ms=" << to_string(drop_time_ms);
  out << ", " << "is_alive=" << to_string(is_alive);
  out << ", " << "is_collected=" << to_string(is_collected);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "last_prepared_decree=" << to_string(last_prepared_decree);
  out << ")";
}


ddd_partition_info::~ddd_partition_info() throw() {
}


void ddd_partition_info::__set_config(const  ::dsn::partition_configuration& val) {
  this->config = val;
}

void ddd_partition_info::__set_dropped(const std::vector<ddd_node_info> & val) {
  this->dropped = val;
}

void ddd_partition_info::__set_reason(const std::string& val) {
  this->reason = val;
}

uint32_t ddd_partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dropped.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _etype195;
            xfer += iprot->readListBegin(_etype195, _size192);
            this->dropped.resize(_size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              xfer += this->dropped[_i196].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dropped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_partition_info");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropped", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dropped.size()));
    std::vector<ddd_node_info> ::const_iterator _iter197;
    for (_iter197 = this->dropped.begin(); _iter197 != this->dropped.end(); ++_iter197)
    {
      xfer += (*_iter197).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_partition_info &a, ddd_partition_info &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.dropped, b.dropped);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

ddd_partition_info::ddd_partition_info(const ddd_partition_info& other198) {
  config = other198.config;
  dropped = other198.dropped;
  reason = other198.reason;
  __isset = other198.__isset;
}
ddd_partition_info& ddd_partition_info::operator=(const ddd_partition_info& other199) {
  config = other199.config;
  dropped = other199.dropped;
  reason = other199.reason;
  __isset = other199.__isset;
  return *this;
}
void ddd_partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_partition_info(";
  out << "config=" << to_string(config);
  out << ", " << "dropped=" << to_string(dropped);
  out << ", " << "reason=" << to_string(reason);
  out << ")";
}


ddd_diagnose_response::~ddd_diagnose_response() throw() {
}


void ddd_diagnose_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void ddd_diagnose_response::__set_partitions(const std::vector<ddd_partition_info> & val) {
  this->partitions = val;
}

uint32_t ddd_diagnose_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->partitions.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->partitions[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ddd_diagnose_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ddd_diagnose_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<ddd_partition_info> ::const_iterator _iter205;
    for (_iter205 = this->partitions.begin(); _iter205 != this->partitions.end(); ++_iter205)
    {
      xfer += (*_iter205).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ddd_diagnose_response &a, ddd_diagnose_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

ddd_diagnose_response::ddd_diagnose_response(const ddd_diagnose_response& other206) {
  err = other206.err;
  partitions = other206.partitions;
  __isset = other206.__isset;
}
ddd_diagnose_response& ddd_diagnose_response::operator=(const ddd_diagnose_response& other207) {
  err = other207.err;
  partitions = other207.partitions;
  __isset = other207.__isset;
  return *this;
}
void ddd_diagnose_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ddd_diagnose_response(";
  out << "err=" << to_string(err);
  out << ", " << "partitions=" << to_string(partitions);
  out << ")";
}


configuration_get_max_replica_count_request::~configuration_get_max_replica_count_request() throw() {
}


void configuration_get_max_replica_count_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t configuration_get_max_replica_count_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_get_max_replica_count_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_get_max_replica_count_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_get_max_replica_count_request &a, configuration_get_max_replica_count_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

configuration_get_max_replica_count_request::configuration_get_max_replica_count_request(const configuration_get_max_replica_count_request& other208) {
  app_name = other208.app_name;
  __isset = other208.__isset;
}
configuration_get_max_replica_count_request& configuration_get_max_replica_count_request::operator=(const configuration_get_max_replica_count_request& other209) {
  app_name = other209.app_name;
  __isset = other209.__isset;
  return *this;
}
void configuration_get_max_replica_count_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_get_max_replica_count_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


configuration_get_max_replica_count_response::~configuration_get_max_replica_count_response() throw() {
}


void configuration_get_max_replica_count_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_get_max_replica_count_response::__set_max_replica_count(const int32_t val) {
  this->max_replica_count = val;
}

void configuration_get_max_replica_count_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_get_max_replica_count_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_replica_count);
          this->__isset.max_replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_get_max_replica_count_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_get_max_replica_count_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max_replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_get_max_replica_count_response &a, configuration_get_max_replica_count_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.max_replica_count, b.max_replica_count);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_get_max_replica_count_response::configuration_get_max_replica_count_response(const configuration_get_max_replica_count_response& other210) {
  err = other210.err;
  max_replica_count = other210.max_replica_count;
  hint_message = other210.hint_message;
  __isset = other210.__isset;
}
configuration_get_max_replica_count_response& configuration_get_max_replica_count_response::operator=(const configuration_get_max_replica_count_response& other211) {
  err = other211.err;
  max_replica_count = other211.max_replica_count;
  hint_message = other211.hint_message;
  __isset = other211.__isset;
  return *this;
}
void configuration_get_max_replica_count_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_get_max_replica_count_response(";
  out << "err=" << to_string(err);
  out << ", " << "max_replica_count=" << to_string(max_replica_count);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


configuration_set_max_replica_count_request::~configuration_set_max_replica_count_request() throw() {
}


void configuration_set_max_replica_count_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_set_max_replica_count_request::__set_max_replica_count(const int32_t val) {
  this->max_replica_count = val;
}

uint32_t configuration_set_max_replica_count_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_replica_count);
          this->__isset.max_replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_set_max_replica_count_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_set_max_replica_count_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max_replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_set_max_replica_count_request &a, configuration_set_max_replica_count_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.max_replica_count, b.max_replica_count);
  swap(a.__isset, b.__isset);
}

configuration_set_max_replica_count_request::configuration_set_max_replica_count_request(const configuration_set_max_replica_count_request& other212) {
  app_name = other212.app_name;
  max_replica_count = other212.max_replica_count;
  __isset = other212.__isset;
}
configuration_set_max_replica_count_request& configuration_set_max_replica_count_request::operator=(const configuration_set_max_replica_count_request& other213) {
  app_name = other213.app_name;
  max_replica_count = other213.max_replica_count;
  __isset = other213.__isset;
  return *this;
}
void configuration_set_max_replica_count_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_set_max_replica_count_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "max_replica_count=" << to_string(max_replica_count);
  out << ")";
}


configuration_set_max_replica_count_response::~configuration_set_max_replica_count_response() throw() {
}


void configuration_set_max_replica_count_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_set_max_replica_count_response::__set_old_max_replica_count(const int32_t val) {
  this->old_max_replica_count = val;
}

void configuration_set_max_replica_count_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_set_max_replica_count_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->old_max_replica_count);
          this->__isset.old_max_replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_set_max_replica_count_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_set_max_replica_count_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("old_max_replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->old_max_replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_set_max_replica_count_response &a, configuration_set_max_replica_count_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.old_max_replica_count, b.old_max_replica_count);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_set_max_replica_count_response::configuration_set_max_replica_count_response(const configuration_set_max_replica_count_response& other214) {
  err = other214.err;
  old_max_replica_count = other214.old_max_replica_count;
  hint_message = other214.hint_message;
  __isset = other214.__isset;
}
configuration_set_max_replica_count_response& configuration_set_max_replica_count_response::operator=(const configuration_set_max_replica_count_response& other215) {
  err = other215.err;
  old_max_replica_count = other215.old_max_replica_count;
  hint_message = other215.hint_message;
  __isset = other215.__isset;
  return *this;
}
void configuration_set_max_replica_count_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_set_max_replica_count_response(";
  out << "err=" << to_string(err);
  out << ", " << "old_max_replica_count=" << to_string(old_max_replica_count);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}

}} // namespace
