/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "bulk_load_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kbulk_load_statusValues[] = {
  bulk_load_status::BLS_INVALID,
  bulk_load_status::BLS_DOWNLOADING,
  bulk_load_status::BLS_DOWNLOADED,
  bulk_load_status::BLS_INGESTING,
  bulk_load_status::BLS_SUCCEED,
  bulk_load_status::BLS_FAILED,
  bulk_load_status::BLS_PAUSING,
  bulk_load_status::BLS_PAUSED,
  bulk_load_status::BLS_CANCELED
};
const char* _kbulk_load_statusNames[] = {
  "BLS_INVALID",
  "BLS_DOWNLOADING",
  "BLS_DOWNLOADED",
  "BLS_INGESTING",
  "BLS_SUCCEED",
  "BLS_FAILED",
  "BLS_PAUSING",
  "BLS_PAUSED",
  "BLS_CANCELED"
};
const std::map<int, const char*> _bulk_load_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kbulk_load_statusValues, _kbulk_load_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kingestion_statusValues[] = {
  ingestion_status::IS_INVALID,
  ingestion_status::IS_RUNNING,
  ingestion_status::IS_SUCCEED,
  ingestion_status::IS_FAILED
};
const char* _kingestion_statusNames[] = {
  "IS_INVALID",
  "IS_RUNNING",
  "IS_SUCCEED",
  "IS_FAILED"
};
const std::map<int, const char*> _ingestion_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kingestion_statusValues, _kingestion_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbulk_load_control_typeValues[] = {
  bulk_load_control_type::BLC_PAUSE,
  bulk_load_control_type::BLC_RESTART,
  bulk_load_control_type::BLC_CANCEL,
  bulk_load_control_type::BLC_FORCE_CANCEL
};
const char* _kbulk_load_control_typeNames[] = {
  "BLC_PAUSE",
  "BLC_RESTART",
  "BLC_CANCEL",
  "BLC_FORCE_CANCEL"
};
const std::map<int, const char*> _bulk_load_control_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kbulk_load_control_typeValues, _kbulk_load_control_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


bulk_load_metadata::~bulk_load_metadata() throw() {
}


void bulk_load_metadata::__set_files(const std::vector< ::dsn::replication::file_meta> & val) {
  this->files = val;
}

void bulk_load_metadata::__set_file_total_size(const int64_t val) {
  this->file_total_size = val;
}

uint32_t bulk_load_metadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->files.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->files[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->file_total_size);
          this->__isset.file_total_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t bulk_load_metadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("bulk_load_metadata");

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->files.size()));
    std::vector< ::dsn::replication::file_meta> ::const_iterator _iter5;
    for (_iter5 = this->files.begin(); _iter5 != this->files.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_total_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->file_total_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(bulk_load_metadata &a, bulk_load_metadata &b) {
  using ::std::swap;
  swap(a.files, b.files);
  swap(a.file_total_size, b.file_total_size);
  swap(a.__isset, b.__isset);
}

bulk_load_metadata::bulk_load_metadata(const bulk_load_metadata& other6) {
  files = other6.files;
  file_total_size = other6.file_total_size;
  __isset = other6.__isset;
}
bulk_load_metadata& bulk_load_metadata::operator=(const bulk_load_metadata& other7) {
  files = other7.files;
  file_total_size = other7.file_total_size;
  __isset = other7.__isset;
  return *this;
}
void bulk_load_metadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "bulk_load_metadata(";
  out << "files=" << to_string(files);
  out << ", " << "file_total_size=" << to_string(file_total_size);
  out << ")";
}


start_bulk_load_request::~start_bulk_load_request() throw() {
}


void start_bulk_load_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void start_bulk_load_request::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
}

void start_bulk_load_request::__set_file_provider_type(const std::string& val) {
  this->file_provider_type = val;
}

void start_bulk_load_request::__set_remote_root_path(const std::string& val) {
  this->remote_root_path = val;
}

void start_bulk_load_request::__set_ingest_behind(const bool val) {
  this->ingest_behind = val;
}

uint32_t start_bulk_load_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_provider_type);
          this->__isset.file_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_root_path);
          this->__isset.remote_root_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ingest_behind);
          this->__isset.ingest_behind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_bulk_load_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_bulk_load_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cluster_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_provider_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->file_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->remote_root_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ingest_behind", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->ingest_behind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_bulk_load_request &a, start_bulk_load_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.cluster_name, b.cluster_name);
  swap(a.file_provider_type, b.file_provider_type);
  swap(a.remote_root_path, b.remote_root_path);
  swap(a.ingest_behind, b.ingest_behind);
  swap(a.__isset, b.__isset);
}

start_bulk_load_request::start_bulk_load_request(const start_bulk_load_request& other8) {
  app_name = other8.app_name;
  cluster_name = other8.cluster_name;
  file_provider_type = other8.file_provider_type;
  remote_root_path = other8.remote_root_path;
  ingest_behind = other8.ingest_behind;
  __isset = other8.__isset;
}
start_bulk_load_request& start_bulk_load_request::operator=(const start_bulk_load_request& other9) {
  app_name = other9.app_name;
  cluster_name = other9.cluster_name;
  file_provider_type = other9.file_provider_type;
  remote_root_path = other9.remote_root_path;
  ingest_behind = other9.ingest_behind;
  __isset = other9.__isset;
  return *this;
}
void start_bulk_load_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_bulk_load_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "cluster_name=" << to_string(cluster_name);
  out << ", " << "file_provider_type=" << to_string(file_provider_type);
  out << ", " << "remote_root_path=" << to_string(remote_root_path);
  out << ", " << "ingest_behind=" << to_string(ingest_behind);
  out << ")";
}


start_bulk_load_response::~start_bulk_load_response() throw() {
}


void start_bulk_load_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void start_bulk_load_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
}

uint32_t start_bulk_load_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_bulk_load_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_bulk_load_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_bulk_load_response &a, start_bulk_load_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

start_bulk_load_response::start_bulk_load_response(const start_bulk_load_response& other10) {
  err = other10.err;
  hint_msg = other10.hint_msg;
  __isset = other10.__isset;
}
start_bulk_load_response& start_bulk_load_response::operator=(const start_bulk_load_response& other11) {
  err = other11.err;
  hint_msg = other11.hint_msg;
  __isset = other11.__isset;
  return *this;
}
void start_bulk_load_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_bulk_load_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg=" << to_string(hint_msg);
  out << ")";
}


partition_bulk_load_state::~partition_bulk_load_state() throw() {
}


void partition_bulk_load_state::__set_download_progress(const int32_t val) {
  this->download_progress = val;
__isset.download_progress = true;
}

void partition_bulk_load_state::__set_download_status(const  ::dsn::error_code& val) {
  this->download_status = val;
__isset.download_status = true;
}

void partition_bulk_load_state::__set_ingest_status(const ingestion_status::type val) {
  this->ingest_status = val;
__isset.ingest_status = true;
}

void partition_bulk_load_state::__set_is_cleaned_up(const bool val) {
  this->is_cleaned_up = val;
__isset.is_cleaned_up = true;
}

void partition_bulk_load_state::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

uint32_t partition_bulk_load_state::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_progress);
          this->__isset.download_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->download_status.read(iprot);
          this->__isset.download_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->ingest_status = (ingestion_status::type)ecast12;
          this->__isset.ingest_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cleaned_up);
          this->__isset.is_cleaned_up = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_bulk_load_state::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_bulk_load_state");

  if (this->__isset.download_progress) {
    xfer += oprot->writeFieldBegin("download_progress", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->download_progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.download_status) {
    xfer += oprot->writeFieldBegin("download_status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->download_status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ingest_status) {
    xfer += oprot->writeFieldBegin("ingest_status", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->ingest_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cleaned_up) {
    xfer += oprot->writeFieldBegin("is_cleaned_up", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_cleaned_up);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_bulk_load_state &a, partition_bulk_load_state &b) {
  using ::std::swap;
  swap(a.download_progress, b.download_progress);
  swap(a.download_status, b.download_status);
  swap(a.ingest_status, b.ingest_status);
  swap(a.is_cleaned_up, b.is_cleaned_up);
  swap(a.is_paused, b.is_paused);
  swap(a.__isset, b.__isset);
}

partition_bulk_load_state::partition_bulk_load_state(const partition_bulk_load_state& other13) {
  download_progress = other13.download_progress;
  download_status = other13.download_status;
  ingest_status = other13.ingest_status;
  is_cleaned_up = other13.is_cleaned_up;
  is_paused = other13.is_paused;
  __isset = other13.__isset;
}
partition_bulk_load_state& partition_bulk_load_state::operator=(const partition_bulk_load_state& other14) {
  download_progress = other14.download_progress;
  download_status = other14.download_status;
  ingest_status = other14.ingest_status;
  is_cleaned_up = other14.is_cleaned_up;
  is_paused = other14.is_paused;
  __isset = other14.__isset;
  return *this;
}
void partition_bulk_load_state::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_bulk_load_state(";
  out << "download_progress="; (__isset.download_progress ? (out << to_string(download_progress)) : (out << "<null>"));
  out << ", " << "download_status="; (__isset.download_status ? (out << to_string(download_status)) : (out << "<null>"));
  out << ", " << "ingest_status="; (__isset.ingest_status ? (out << to_string(ingest_status)) : (out << "<null>"));
  out << ", " << "is_cleaned_up="; (__isset.is_cleaned_up ? (out << to_string(is_cleaned_up)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ")";
}


bulk_load_request::~bulk_load_request() throw() {
}


void bulk_load_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void bulk_load_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void bulk_load_request::__set_primary_addr(const  ::dsn::rpc_address& val) {
  this->primary_addr = val;
}

void bulk_load_request::__set_remote_provider_name(const std::string& val) {
  this->remote_provider_name = val;
}

void bulk_load_request::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
}

void bulk_load_request::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void bulk_load_request::__set_meta_bulk_load_status(const bulk_load_status::type val) {
  this->meta_bulk_load_status = val;
}

void bulk_load_request::__set_query_bulk_load_metadata(const bool val) {
  this->query_bulk_load_metadata = val;
}

void bulk_load_request::__set_remote_root_path(const std::string& val) {
  this->remote_root_path = val;
}

uint32_t bulk_load_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primary_addr.read(iprot);
          this->__isset.primary_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_provider_name);
          this->__isset.remote_provider_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->meta_bulk_load_status = (bulk_load_status::type)ecast15;
          this->__isset.meta_bulk_load_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->query_bulk_load_metadata);
          this->__isset.query_bulk_load_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_root_path);
          this->__isset.remote_root_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t bulk_load_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("bulk_load_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary_addr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->primary_addr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_provider_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->remote_provider_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->cluster_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meta_bulk_load_status", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->meta_bulk_load_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_bulk_load_metadata", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->query_bulk_load_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->remote_root_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(bulk_load_request &a, bulk_load_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.app_name, b.app_name);
  swap(a.primary_addr, b.primary_addr);
  swap(a.remote_provider_name, b.remote_provider_name);
  swap(a.cluster_name, b.cluster_name);
  swap(a.ballot, b.ballot);
  swap(a.meta_bulk_load_status, b.meta_bulk_load_status);
  swap(a.query_bulk_load_metadata, b.query_bulk_load_metadata);
  swap(a.remote_root_path, b.remote_root_path);
  swap(a.__isset, b.__isset);
}

bulk_load_request::bulk_load_request(const bulk_load_request& other16) {
  pid = other16.pid;
  app_name = other16.app_name;
  primary_addr = other16.primary_addr;
  remote_provider_name = other16.remote_provider_name;
  cluster_name = other16.cluster_name;
  ballot = other16.ballot;
  meta_bulk_load_status = other16.meta_bulk_load_status;
  query_bulk_load_metadata = other16.query_bulk_load_metadata;
  remote_root_path = other16.remote_root_path;
  __isset = other16.__isset;
}
bulk_load_request& bulk_load_request::operator=(const bulk_load_request& other17) {
  pid = other17.pid;
  app_name = other17.app_name;
  primary_addr = other17.primary_addr;
  remote_provider_name = other17.remote_provider_name;
  cluster_name = other17.cluster_name;
  ballot = other17.ballot;
  meta_bulk_load_status = other17.meta_bulk_load_status;
  query_bulk_load_metadata = other17.query_bulk_load_metadata;
  remote_root_path = other17.remote_root_path;
  __isset = other17.__isset;
  return *this;
}
void bulk_load_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "bulk_load_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "primary_addr=" << to_string(primary_addr);
  out << ", " << "remote_provider_name=" << to_string(remote_provider_name);
  out << ", " << "cluster_name=" << to_string(cluster_name);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "meta_bulk_load_status=" << to_string(meta_bulk_load_status);
  out << ", " << "query_bulk_load_metadata=" << to_string(query_bulk_load_metadata);
  out << ", " << "remote_root_path=" << to_string(remote_root_path);
  out << ")";
}


bulk_load_response::~bulk_load_response() throw() {
}


void bulk_load_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void bulk_load_response::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void bulk_load_response::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void bulk_load_response::__set_primary_bulk_load_status(const bulk_load_status::type val) {
  this->primary_bulk_load_status = val;
}

void bulk_load_response::__set_group_bulk_load_state(const std::map< ::dsn::rpc_address, partition_bulk_load_state> & val) {
  this->group_bulk_load_state = val;
}

void bulk_load_response::__set_metadata(const bulk_load_metadata& val) {
  this->metadata = val;
__isset.metadata = true;
}

void bulk_load_response::__set_total_download_progress(const int32_t val) {
  this->total_download_progress = val;
__isset.total_download_progress = true;
}

void bulk_load_response::__set_is_group_ingestion_finished(const bool val) {
  this->is_group_ingestion_finished = val;
__isset.is_group_ingestion_finished = true;
}

void bulk_load_response::__set_is_group_bulk_load_context_cleaned_up(const bool val) {
  this->is_group_bulk_load_context_cleaned_up = val;
__isset.is_group_bulk_load_context_cleaned_up = true;
}

void bulk_load_response::__set_is_group_bulk_load_paused(const bool val) {
  this->is_group_bulk_load_paused = val;
__isset.is_group_bulk_load_paused = true;
}

uint32_t bulk_load_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->primary_bulk_load_status = (bulk_load_status::type)ecast18;
          this->__isset.primary_bulk_load_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->group_bulk_load_state.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            xfer += iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
               ::dsn::rpc_address _key24;
              xfer += _key24.read(iprot);
              partition_bulk_load_state& _val25 = this->group_bulk_load_state[_key24];
              xfer += _val25.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.group_bulk_load_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_download_progress);
          this->__isset.total_download_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_group_ingestion_finished);
          this->__isset.is_group_ingestion_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_group_bulk_load_context_cleaned_up);
          this->__isset.is_group_bulk_load_context_cleaned_up = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_group_bulk_load_paused);
          this->__isset.is_group_bulk_load_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t bulk_load_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("bulk_load_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary_bulk_load_status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->primary_bulk_load_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group_bulk_load_state", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_bulk_load_state.size()));
    std::map< ::dsn::rpc_address, partition_bulk_load_state> ::const_iterator _iter26;
    for (_iter26 = this->group_bulk_load_state.begin(); _iter26 != this->group_bulk_load_state.end(); ++_iter26)
    {
      xfer += _iter26->first.write(oprot);
      xfer += _iter26->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_download_progress) {
    xfer += oprot->writeFieldBegin("total_download_progress", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->total_download_progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_group_ingestion_finished) {
    xfer += oprot->writeFieldBegin("is_group_ingestion_finished", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_group_ingestion_finished);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_group_bulk_load_context_cleaned_up) {
    xfer += oprot->writeFieldBegin("is_group_bulk_load_context_cleaned_up", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_group_bulk_load_context_cleaned_up);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_group_bulk_load_paused) {
    xfer += oprot->writeFieldBegin("is_group_bulk_load_paused", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_group_bulk_load_paused);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(bulk_load_response &a, bulk_load_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.pid, b.pid);
  swap(a.app_name, b.app_name);
  swap(a.primary_bulk_load_status, b.primary_bulk_load_status);
  swap(a.group_bulk_load_state, b.group_bulk_load_state);
  swap(a.metadata, b.metadata);
  swap(a.total_download_progress, b.total_download_progress);
  swap(a.is_group_ingestion_finished, b.is_group_ingestion_finished);
  swap(a.is_group_bulk_load_context_cleaned_up, b.is_group_bulk_load_context_cleaned_up);
  swap(a.is_group_bulk_load_paused, b.is_group_bulk_load_paused);
  swap(a.__isset, b.__isset);
}

bulk_load_response::bulk_load_response(const bulk_load_response& other27) {
  err = other27.err;
  pid = other27.pid;
  app_name = other27.app_name;
  primary_bulk_load_status = other27.primary_bulk_load_status;
  group_bulk_load_state = other27.group_bulk_load_state;
  metadata = other27.metadata;
  total_download_progress = other27.total_download_progress;
  is_group_ingestion_finished = other27.is_group_ingestion_finished;
  is_group_bulk_load_context_cleaned_up = other27.is_group_bulk_load_context_cleaned_up;
  is_group_bulk_load_paused = other27.is_group_bulk_load_paused;
  __isset = other27.__isset;
}
bulk_load_response& bulk_load_response::operator=(const bulk_load_response& other28) {
  err = other28.err;
  pid = other28.pid;
  app_name = other28.app_name;
  primary_bulk_load_status = other28.primary_bulk_load_status;
  group_bulk_load_state = other28.group_bulk_load_state;
  metadata = other28.metadata;
  total_download_progress = other28.total_download_progress;
  is_group_ingestion_finished = other28.is_group_ingestion_finished;
  is_group_bulk_load_context_cleaned_up = other28.is_group_bulk_load_context_cleaned_up;
  is_group_bulk_load_paused = other28.is_group_bulk_load_paused;
  __isset = other28.__isset;
  return *this;
}
void bulk_load_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "bulk_load_response(";
  out << "err=" << to_string(err);
  out << ", " << "pid=" << to_string(pid);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "primary_bulk_load_status=" << to_string(primary_bulk_load_status);
  out << ", " << "group_bulk_load_state=" << to_string(group_bulk_load_state);
  out << ", " << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "total_download_progress="; (__isset.total_download_progress ? (out << to_string(total_download_progress)) : (out << "<null>"));
  out << ", " << "is_group_ingestion_finished="; (__isset.is_group_ingestion_finished ? (out << to_string(is_group_ingestion_finished)) : (out << "<null>"));
  out << ", " << "is_group_bulk_load_context_cleaned_up="; (__isset.is_group_bulk_load_context_cleaned_up ? (out << to_string(is_group_bulk_load_context_cleaned_up)) : (out << "<null>"));
  out << ", " << "is_group_bulk_load_paused="; (__isset.is_group_bulk_load_paused ? (out << to_string(is_group_bulk_load_paused)) : (out << "<null>"));
  out << ")";
}


group_bulk_load_request::~group_bulk_load_request() throw() {
}


void group_bulk_load_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void group_bulk_load_request::__set_target_address(const  ::dsn::rpc_address& val) {
  this->target_address = val;
}

void group_bulk_load_request::__set_config(const  ::dsn::replication::replica_configuration& val) {
  this->config = val;
}

void group_bulk_load_request::__set_provider_name(const std::string& val) {
  this->provider_name = val;
}

void group_bulk_load_request::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
}

void group_bulk_load_request::__set_meta_bulk_load_status(const bulk_load_status::type val) {
  this->meta_bulk_load_status = val;
}

void group_bulk_load_request::__set_remote_root_path(const std::string& val) {
  this->remote_root_path = val;
}

uint32_t group_bulk_load_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target_address.read(iprot);
          this->__isset.target_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->provider_name);
          this->__isset.provider_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->meta_bulk_load_status = (bulk_load_status::type)ecast29;
          this->__isset.meta_bulk_load_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_root_path);
          this->__isset.remote_root_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_bulk_load_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_bulk_load_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_address", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("provider_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->provider_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->cluster_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meta_bulk_load_status", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->meta_bulk_load_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote_root_path", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->remote_root_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_bulk_load_request &a, group_bulk_load_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.target_address, b.target_address);
  swap(a.config, b.config);
  swap(a.provider_name, b.provider_name);
  swap(a.cluster_name, b.cluster_name);
  swap(a.meta_bulk_load_status, b.meta_bulk_load_status);
  swap(a.remote_root_path, b.remote_root_path);
  swap(a.__isset, b.__isset);
}

group_bulk_load_request::group_bulk_load_request(const group_bulk_load_request& other30) {
  app_name = other30.app_name;
  target_address = other30.target_address;
  config = other30.config;
  provider_name = other30.provider_name;
  cluster_name = other30.cluster_name;
  meta_bulk_load_status = other30.meta_bulk_load_status;
  remote_root_path = other30.remote_root_path;
  __isset = other30.__isset;
}
group_bulk_load_request& group_bulk_load_request::operator=(const group_bulk_load_request& other31) {
  app_name = other31.app_name;
  target_address = other31.target_address;
  config = other31.config;
  provider_name = other31.provider_name;
  cluster_name = other31.cluster_name;
  meta_bulk_load_status = other31.meta_bulk_load_status;
  remote_root_path = other31.remote_root_path;
  __isset = other31.__isset;
  return *this;
}
void group_bulk_load_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_bulk_load_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "target_address=" << to_string(target_address);
  out << ", " << "config=" << to_string(config);
  out << ", " << "provider_name=" << to_string(provider_name);
  out << ", " << "cluster_name=" << to_string(cluster_name);
  out << ", " << "meta_bulk_load_status=" << to_string(meta_bulk_load_status);
  out << ", " << "remote_root_path=" << to_string(remote_root_path);
  out << ")";
}


group_bulk_load_response::~group_bulk_load_response() throw() {
}


void group_bulk_load_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void group_bulk_load_response::__set_status(const bulk_load_status::type val) {
  this->status = val;
}

void group_bulk_load_response::__set_bulk_load_state(const partition_bulk_load_state& val) {
  this->bulk_load_state = val;
}

uint32_t group_bulk_load_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->status = (bulk_load_status::type)ecast32;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bulk_load_state.read(iprot);
          this->__isset.bulk_load_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_bulk_load_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_bulk_load_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulk_load_state", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->bulk_load_state.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_bulk_load_response &a, group_bulk_load_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.status, b.status);
  swap(a.bulk_load_state, b.bulk_load_state);
  swap(a.__isset, b.__isset);
}

group_bulk_load_response::group_bulk_load_response(const group_bulk_load_response& other33) {
  err = other33.err;
  status = other33.status;
  bulk_load_state = other33.bulk_load_state;
  __isset = other33.__isset;
}
group_bulk_load_response& group_bulk_load_response::operator=(const group_bulk_load_response& other34) {
  err = other34.err;
  status = other34.status;
  bulk_load_state = other34.bulk_load_state;
  __isset = other34.__isset;
  return *this;
}
void group_bulk_load_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_bulk_load_response(";
  out << "err=" << to_string(err);
  out << ", " << "status=" << to_string(status);
  out << ", " << "bulk_load_state=" << to_string(bulk_load_state);
  out << ")";
}


ingestion_request::~ingestion_request() throw() {
}


void ingestion_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void ingestion_request::__set_metadata(const bulk_load_metadata& val) {
  this->metadata = val;
}

void ingestion_request::__set_ingest_behind(const bool val) {
  this->ingest_behind = val;
}

void ingestion_request::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void ingestion_request::__set_verify_before_ingest(const bool val) {
  this->verify_before_ingest = val;
}

uint32_t ingestion_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ingest_behind);
          this->__isset.ingest_behind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->verify_before_ingest);
          this->__isset.verify_before_ingest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ingestion_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ingestion_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ingest_behind", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->ingest_behind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verify_before_ingest", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->verify_before_ingest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ingestion_request &a, ingestion_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.metadata, b.metadata);
  swap(a.ingest_behind, b.ingest_behind);
  swap(a.ballot, b.ballot);
  swap(a.verify_before_ingest, b.verify_before_ingest);
  swap(a.__isset, b.__isset);
}

ingestion_request::ingestion_request(const ingestion_request& other35) {
  app_name = other35.app_name;
  metadata = other35.metadata;
  ingest_behind = other35.ingest_behind;
  ballot = other35.ballot;
  verify_before_ingest = other35.verify_before_ingest;
  __isset = other35.__isset;
}
ingestion_request& ingestion_request::operator=(const ingestion_request& other36) {
  app_name = other36.app_name;
  metadata = other36.metadata;
  ingest_behind = other36.ingest_behind;
  ballot = other36.ballot;
  verify_before_ingest = other36.verify_before_ingest;
  __isset = other36.__isset;
  return *this;
}
void ingestion_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ingestion_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "metadata=" << to_string(metadata);
  out << ", " << "ingest_behind=" << to_string(ingest_behind);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "verify_before_ingest=" << to_string(verify_before_ingest);
  out << ")";
}


ingestion_response::~ingestion_response() throw() {
}


void ingestion_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void ingestion_response::__set_rocksdb_error(const int32_t val) {
  this->rocksdb_error = val;
}

uint32_t ingestion_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rocksdb_error);
          this->__isset.rocksdb_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ingestion_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ingestion_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rocksdb_error", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->rocksdb_error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ingestion_response &a, ingestion_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.rocksdb_error, b.rocksdb_error);
  swap(a.__isset, b.__isset);
}

ingestion_response::ingestion_response(const ingestion_response& other37) {
  err = other37.err;
  rocksdb_error = other37.rocksdb_error;
  __isset = other37.__isset;
}
ingestion_response& ingestion_response::operator=(const ingestion_response& other38) {
  err = other38.err;
  rocksdb_error = other38.rocksdb_error;
  __isset = other38.__isset;
  return *this;
}
void ingestion_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ingestion_response(";
  out << "err=" << to_string(err);
  out << ", " << "rocksdb_error=" << to_string(rocksdb_error);
  out << ")";
}


control_bulk_load_request::~control_bulk_load_request() throw() {
}


void control_bulk_load_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void control_bulk_load_request::__set_type(const bulk_load_control_type::type val) {
  this->type = val;
}

uint32_t control_bulk_load_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast39;
          xfer += iprot->readI32(ecast39);
          this->type = (bulk_load_control_type::type)ecast39;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_bulk_load_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_bulk_load_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_bulk_load_request &a, control_bulk_load_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

control_bulk_load_request::control_bulk_load_request(const control_bulk_load_request& other40) {
  app_name = other40.app_name;
  type = other40.type;
  __isset = other40.__isset;
}
control_bulk_load_request& control_bulk_load_request::operator=(const control_bulk_load_request& other41) {
  app_name = other41.app_name;
  type = other41.type;
  __isset = other41.__isset;
  return *this;
}
void control_bulk_load_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_bulk_load_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


control_bulk_load_response::~control_bulk_load_response() throw() {
}


void control_bulk_load_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void control_bulk_load_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
__isset.hint_msg = true;
}

uint32_t control_bulk_load_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_bulk_load_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_bulk_load_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint_msg) {
    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_bulk_load_response &a, control_bulk_load_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

control_bulk_load_response::control_bulk_load_response(const control_bulk_load_response& other42) {
  err = other42.err;
  hint_msg = other42.hint_msg;
  __isset = other42.__isset;
}
control_bulk_load_response& control_bulk_load_response::operator=(const control_bulk_load_response& other43) {
  err = other43.err;
  hint_msg = other43.hint_msg;
  __isset = other43.__isset;
  return *this;
}
void control_bulk_load_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_bulk_load_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg="; (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
  out << ")";
}


query_bulk_load_request::~query_bulk_load_request() throw() {
}


void query_bulk_load_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t query_bulk_load_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_bulk_load_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_bulk_load_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_bulk_load_request &a, query_bulk_load_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

query_bulk_load_request::query_bulk_load_request(const query_bulk_load_request& other44) {
  app_name = other44.app_name;
  __isset = other44.__isset;
}
query_bulk_load_request& query_bulk_load_request::operator=(const query_bulk_load_request& other45) {
  app_name = other45.app_name;
  __isset = other45.__isset;
  return *this;
}
void query_bulk_load_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_bulk_load_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


query_bulk_load_response::~query_bulk_load_response() throw() {
}


void query_bulk_load_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_bulk_load_response::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void query_bulk_load_response::__set_app_status(const bulk_load_status::type val) {
  this->app_status = val;
}

void query_bulk_load_response::__set_partitions_status(const std::vector<bulk_load_status::type> & val) {
  this->partitions_status = val;
}

void query_bulk_load_response::__set_max_replica_count(const int32_t val) {
  this->max_replica_count = val;
}

void query_bulk_load_response::__set_bulk_load_states(const std::vector<std::map< ::dsn::rpc_address, partition_bulk_load_state> > & val) {
  this->bulk_load_states = val;
}

void query_bulk_load_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
__isset.hint_msg = true;
}

void query_bulk_load_response::__set_is_bulk_loading(const bool val) {
  this->is_bulk_loading = val;
__isset.is_bulk_loading = true;
}

uint32_t query_bulk_load_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast46;
          xfer += iprot->readI32(ecast46);
          this->app_status = (bulk_load_status::type)ecast46;
          this->__isset.app_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions_status.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->partitions_status.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              int32_t ecast52;
              xfer += iprot->readI32(ecast52);
              this->partitions_status[_i51] = (bulk_load_status::type)ecast52;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_replica_count);
          this->__isset.max_replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bulk_load_states.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->bulk_load_states.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              {
                this->bulk_load_states[_i57].clear();
                uint32_t _size58;
                ::apache::thrift::protocol::TType _ktype59;
                ::apache::thrift::protocol::TType _vtype60;
                xfer += iprot->readMapBegin(_ktype59, _vtype60, _size58);
                uint32_t _i62;
                for (_i62 = 0; _i62 < _size58; ++_i62)
                {
                   ::dsn::rpc_address _key63;
                  xfer += _key63.read(iprot);
                  partition_bulk_load_state& _val64 = this->bulk_load_states[_i57][_key63];
                  xfer += _val64.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bulk_load_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_bulk_loading);
          this->__isset.is_bulk_loading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_bulk_load_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_bulk_load_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->app_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions_status", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->partitions_status.size()));
    std::vector<bulk_load_status::type> ::const_iterator _iter65;
    for (_iter65 = this->partitions_status.begin(); _iter65 != this->partitions_status.end(); ++_iter65)
    {
      xfer += oprot->writeI32((int32_t)(*_iter65));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_replica_count", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->max_replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulk_load_states", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->bulk_load_states.size()));
    std::vector<std::map< ::dsn::rpc_address, partition_bulk_load_state> > ::const_iterator _iter66;
    for (_iter66 = this->bulk_load_states.begin(); _iter66 != this->bulk_load_states.end(); ++_iter66)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter66).size()));
        std::map< ::dsn::rpc_address, partition_bulk_load_state> ::const_iterator _iter67;
        for (_iter67 = (*_iter66).begin(); _iter67 != (*_iter66).end(); ++_iter67)
        {
          xfer += _iter67->first.write(oprot);
          xfer += _iter67->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint_msg) {
    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_bulk_loading) {
    xfer += oprot->writeFieldBegin("is_bulk_loading", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_bulk_loading);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_bulk_load_response &a, query_bulk_load_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.app_name, b.app_name);
  swap(a.app_status, b.app_status);
  swap(a.partitions_status, b.partitions_status);
  swap(a.max_replica_count, b.max_replica_count);
  swap(a.bulk_load_states, b.bulk_load_states);
  swap(a.hint_msg, b.hint_msg);
  swap(a.is_bulk_loading, b.is_bulk_loading);
  swap(a.__isset, b.__isset);
}

query_bulk_load_response::query_bulk_load_response(const query_bulk_load_response& other68) {
  err = other68.err;
  app_name = other68.app_name;
  app_status = other68.app_status;
  partitions_status = other68.partitions_status;
  max_replica_count = other68.max_replica_count;
  bulk_load_states = other68.bulk_load_states;
  hint_msg = other68.hint_msg;
  is_bulk_loading = other68.is_bulk_loading;
  __isset = other68.__isset;
}
query_bulk_load_response& query_bulk_load_response::operator=(const query_bulk_load_response& other69) {
  err = other69.err;
  app_name = other69.app_name;
  app_status = other69.app_status;
  partitions_status = other69.partitions_status;
  max_replica_count = other69.max_replica_count;
  bulk_load_states = other69.bulk_load_states;
  hint_msg = other69.hint_msg;
  is_bulk_loading = other69.is_bulk_loading;
  __isset = other69.__isset;
  return *this;
}
void query_bulk_load_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_bulk_load_response(";
  out << "err=" << to_string(err);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "app_status=" << to_string(app_status);
  out << ", " << "partitions_status=" << to_string(partitions_status);
  out << ", " << "max_replica_count=" << to_string(max_replica_count);
  out << ", " << "bulk_load_states=" << to_string(bulk_load_states);
  out << ", " << "hint_msg="; (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
  out << ", " << "is_bulk_loading="; (__isset.is_bulk_loading ? (out << to_string(is_bulk_loading)) : (out << "<null>"));
  out << ")";
}


clear_bulk_load_state_request::~clear_bulk_load_state_request() throw() {
}


void clear_bulk_load_state_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

uint32_t clear_bulk_load_state_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t clear_bulk_load_state_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("clear_bulk_load_state_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(clear_bulk_load_state_request &a, clear_bulk_load_state_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.__isset, b.__isset);
}

clear_bulk_load_state_request::clear_bulk_load_state_request(const clear_bulk_load_state_request& other70) {
  app_name = other70.app_name;
  __isset = other70.__isset;
}
clear_bulk_load_state_request& clear_bulk_load_state_request::operator=(const clear_bulk_load_state_request& other71) {
  app_name = other71.app_name;
  __isset = other71.__isset;
  return *this;
}
void clear_bulk_load_state_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "clear_bulk_load_state_request(";
  out << "app_name=" << to_string(app_name);
  out << ")";
}


clear_bulk_load_state_response::~clear_bulk_load_state_response() throw() {
}


void clear_bulk_load_state_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void clear_bulk_load_state_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
}

uint32_t clear_bulk_load_state_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t clear_bulk_load_state_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("clear_bulk_load_state_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(clear_bulk_load_state_response &a, clear_bulk_load_state_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

clear_bulk_load_state_response::clear_bulk_load_state_response(const clear_bulk_load_state_response& other72) {
  err = other72.err;
  hint_msg = other72.hint_msg;
  __isset = other72.__isset;
}
clear_bulk_load_state_response& clear_bulk_load_state_response::operator=(const clear_bulk_load_state_response& other73) {
  err = other73.err;
  hint_msg = other73.hint_msg;
  __isset = other73.__isset;
  return *this;
}
void clear_bulk_load_state_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "clear_bulk_load_state_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_msg=" << to_string(hint_msg);
  out << ")";
}

}} // namespace
