/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef metadata_TYPES_H
#define metadata_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "dsn_types.h"
#include "dsn.layer2_types.h"


namespace dsn { namespace replication {

struct partition_status {
  enum type {
    PS_INVALID = 0,
    PS_INACTIVE = 1,
    PS_ERROR = 2,
    PS_PRIMARY = 3,
    PS_SECONDARY = 4,
    PS_POTENTIAL_SECONDARY = 5,
    PS_PARTITION_SPLIT = 6
  };
};

extern const std::map<int, const char*> _partition_status_VALUES_TO_NAMES;

struct split_status {
  enum type {
    NOT_SPLIT = 0,
    SPLITTING = 1,
    PAUSING = 2,
    PAUSED = 3,
    CANCELING = 4
  };
};

extern const std::map<int, const char*> _split_status_VALUES_TO_NAMES;

struct disk_status {
  enum type {
    NORMAL = 0,
    SPACE_INSUFFICIENT = 1
  };
};

extern const std::map<int, const char*> _disk_status_VALUES_TO_NAMES;

struct manual_compaction_status {
  enum type {
    IDLE = 0,
    QUEUING = 1,
    RUNNING = 2,
    FINISHED = 3
  };
};

extern const std::map<int, const char*> _manual_compaction_status_VALUES_TO_NAMES;

class file_meta;

class replica_configuration;

class replica_info;

typedef struct _file_meta__isset {
  _file_meta__isset() : name(false), size(false), md5(false) {}
  bool name :1;
  bool size :1;
  bool md5 :1;
} _file_meta__isset;

class file_meta {
 public:

  file_meta(const file_meta&);
  file_meta& operator=(const file_meta&);
  file_meta() : name(), size(0), md5() {
  }

  virtual ~file_meta() throw();
  std::string name;
  int64_t size;
  std::string md5;

  _file_meta__isset __isset;

  void __set_name(const std::string& val);

  void __set_size(const int64_t val);

  void __set_md5(const std::string& val);

  bool operator == (const file_meta & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(md5 == rhs.md5))
      return false;
    return true;
  }
  bool operator != (const file_meta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const file_meta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(file_meta &a, file_meta &b);

inline std::ostream& operator<<(std::ostream& out, const file_meta& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_configuration__isset {
  _replica_configuration__isset() : pid(false), ballot(false), primary(false), status(true), learner_signature(false), pop_all(true), split_sync_to_child(true) {}
  bool pid :1;
  bool ballot :1;
  bool primary :1;
  bool status :1;
  bool learner_signature :1;
  bool pop_all :1;
  bool split_sync_to_child :1;
} _replica_configuration__isset;

class replica_configuration {
 public:

  replica_configuration(const replica_configuration&);
  replica_configuration& operator=(const replica_configuration&);
  replica_configuration() : ballot(0), status((partition_status::type)0), learner_signature(0), pop_all(false), split_sync_to_child(false) {
    status = (partition_status::type)0;

  }

  virtual ~replica_configuration() throw();
   ::dsn::gpid pid;
  int64_t ballot;
   ::dsn::rpc_address primary;
  partition_status::type status;
  int64_t learner_signature;
  bool pop_all;
  bool split_sync_to_child;

  _replica_configuration__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  void __set_primary(const  ::dsn::rpc_address& val);

  void __set_status(const partition_status::type val);

  void __set_learner_signature(const int64_t val);

  void __set_pop_all(const bool val);

  void __set_split_sync_to_child(const bool val);

  bool operator == (const replica_configuration & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    if (__isset.pop_all != rhs.__isset.pop_all)
      return false;
    else if (__isset.pop_all && !(pop_all == rhs.pop_all))
      return false;
    if (__isset.split_sync_to_child != rhs.__isset.split_sync_to_child)
      return false;
    else if (__isset.split_sync_to_child && !(split_sync_to_child == rhs.split_sync_to_child))
      return false;
    return true;
  }
  bool operator != (const replica_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_configuration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_configuration &a, replica_configuration &b);

inline std::ostream& operator<<(std::ostream& out, const replica_configuration& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_info__isset {
  _replica_info__isset() : pid(false), ballot(false), status(false), last_committed_decree(false), last_prepared_decree(false), last_durable_decree(false), app_type(false), disk_tag(false), manual_compact_status(false) {}
  bool pid :1;
  bool ballot :1;
  bool status :1;
  bool last_committed_decree :1;
  bool last_prepared_decree :1;
  bool last_durable_decree :1;
  bool app_type :1;
  bool disk_tag :1;
  bool manual_compact_status :1;
} _replica_info__isset;

class replica_info {
 public:

  replica_info(const replica_info&);
  replica_info& operator=(const replica_info&);
  replica_info() : ballot(0), status((partition_status::type)0), last_committed_decree(0), last_prepared_decree(0), last_durable_decree(0), app_type(), disk_tag(), manual_compact_status((manual_compaction_status::type)0) {
  }

  virtual ~replica_info() throw();
   ::dsn::gpid pid;
  int64_t ballot;
  partition_status::type status;
  int64_t last_committed_decree;
  int64_t last_prepared_decree;
  int64_t last_durable_decree;
  std::string app_type;
  std::string disk_tag;
  manual_compaction_status::type manual_compact_status;

  _replica_info__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  void __set_status(const partition_status::type val);

  void __set_last_committed_decree(const int64_t val);

  void __set_last_prepared_decree(const int64_t val);

  void __set_last_durable_decree(const int64_t val);

  void __set_app_type(const std::string& val);

  void __set_disk_tag(const std::string& val);

  void __set_manual_compact_status(const manual_compaction_status::type val);

  bool operator == (const replica_info & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(last_prepared_decree == rhs.last_prepared_decree))
      return false;
    if (!(last_durable_decree == rhs.last_durable_decree))
      return false;
    if (!(app_type == rhs.app_type))
      return false;
    if (!(disk_tag == rhs.disk_tag))
      return false;
    if (__isset.manual_compact_status != rhs.__isset.manual_compact_status)
      return false;
    else if (__isset.manual_compact_status && !(manual_compact_status == rhs.manual_compact_status))
      return false;
    return true;
  }
  bool operator != (const replica_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_info &a, replica_info &b);

inline std::ostream& operator<<(std::ostream& out, const replica_info& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
