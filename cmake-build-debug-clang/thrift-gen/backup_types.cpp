/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "backup_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {


policy_info::~policy_info() throw() {
}


void policy_info::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void policy_info::__set_backup_provider_type(const std::string& val) {
  this->backup_provider_type = val;
}

uint32_t policy_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_type);
          this->__isset.backup_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t policy_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("policy_info");

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->backup_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(policy_info &a, policy_info &b) {
  using ::std::swap;
  swap(a.policy_name, b.policy_name);
  swap(a.backup_provider_type, b.backup_provider_type);
  swap(a.__isset, b.__isset);
}

policy_info::policy_info(const policy_info& other0) {
  policy_name = other0.policy_name;
  backup_provider_type = other0.backup_provider_type;
  __isset = other0.__isset;
}
policy_info& policy_info::operator=(const policy_info& other1) {
  policy_name = other1.policy_name;
  backup_provider_type = other1.backup_provider_type;
  __isset = other1.__isset;
  return *this;
}
void policy_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "policy_info(";
  out << "policy_name=" << to_string(policy_name);
  out << ", " << "backup_provider_type=" << to_string(backup_provider_type);
  out << ")";
}


configuration_restore_request::~configuration_restore_request() throw() {
}


void configuration_restore_request::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
}

void configuration_restore_request::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void configuration_restore_request::__set_time_stamp(const int64_t val) {
  this->time_stamp = val;
}

void configuration_restore_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_restore_request::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void configuration_restore_request::__set_new_app_name(const std::string& val) {
  this->new_app_name = val;
}

void configuration_restore_request::__set_backup_provider_name(const std::string& val) {
  this->backup_provider_name = val;
}

void configuration_restore_request::__set_skip_bad_partition(const bool val) {
  this->skip_bad_partition = val;
}

void configuration_restore_request::__set_restore_path(const std::string& val) {
  this->restore_path = val;
__isset.restore_path = true;
}

uint32_t configuration_restore_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_app_name);
          this->__isset.new_app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_name);
          this->__isset.backup_provider_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_bad_partition);
          this->__isset.skip_bad_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->restore_path);
          this->__isset.restore_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_restore_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_restore_request");

  xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cluster_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_app_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->new_app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_provider_name", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->backup_provider_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skip_bad_partition", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->skip_bad_partition);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.restore_path) {
    xfer += oprot->writeFieldBegin("restore_path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->restore_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_restore_request &a, configuration_restore_request &b) {
  using ::std::swap;
  swap(a.cluster_name, b.cluster_name);
  swap(a.policy_name, b.policy_name);
  swap(a.time_stamp, b.time_stamp);
  swap(a.app_name, b.app_name);
  swap(a.app_id, b.app_id);
  swap(a.new_app_name, b.new_app_name);
  swap(a.backup_provider_name, b.backup_provider_name);
  swap(a.skip_bad_partition, b.skip_bad_partition);
  swap(a.restore_path, b.restore_path);
  swap(a.__isset, b.__isset);
}

configuration_restore_request::configuration_restore_request(const configuration_restore_request& other2) {
  cluster_name = other2.cluster_name;
  policy_name = other2.policy_name;
  time_stamp = other2.time_stamp;
  app_name = other2.app_name;
  app_id = other2.app_id;
  new_app_name = other2.new_app_name;
  backup_provider_name = other2.backup_provider_name;
  skip_bad_partition = other2.skip_bad_partition;
  restore_path = other2.restore_path;
  __isset = other2.__isset;
}
configuration_restore_request& configuration_restore_request::operator=(const configuration_restore_request& other3) {
  cluster_name = other3.cluster_name;
  policy_name = other3.policy_name;
  time_stamp = other3.time_stamp;
  app_name = other3.app_name;
  app_id = other3.app_id;
  new_app_name = other3.new_app_name;
  backup_provider_name = other3.backup_provider_name;
  skip_bad_partition = other3.skip_bad_partition;
  restore_path = other3.restore_path;
  __isset = other3.__isset;
  return *this;
}
void configuration_restore_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_restore_request(";
  out << "cluster_name=" << to_string(cluster_name);
  out << ", " << "policy_name=" << to_string(policy_name);
  out << ", " << "time_stamp=" << to_string(time_stamp);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "app_id=" << to_string(app_id);
  out << ", " << "new_app_name=" << to_string(new_app_name);
  out << ", " << "backup_provider_name=" << to_string(backup_provider_name);
  out << ", " << "skip_bad_partition=" << to_string(skip_bad_partition);
  out << ", " << "restore_path="; (__isset.restore_path ? (out << to_string(restore_path)) : (out << "<null>"));
  out << ")";
}


backup_request::~backup_request() throw() {
}


void backup_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void backup_request::__set_policy(const policy_info& val) {
  this->policy = val;
}

void backup_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void backup_request::__set_backup_id(const int64_t val) {
  this->backup_id = val;
}

void backup_request::__set_backup_path(const std::string& val) {
  this->backup_path = val;
__isset.backup_path = true;
}

uint32_t backup_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->policy.read(iprot);
          this->__isset.policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_path);
          this->__isset.backup_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backup_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backup_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->policy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->backup_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.backup_path) {
    xfer += oprot->writeFieldBegin("backup_path", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->backup_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backup_request &a, backup_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.policy, b.policy);
  swap(a.app_name, b.app_name);
  swap(a.backup_id, b.backup_id);
  swap(a.backup_path, b.backup_path);
  swap(a.__isset, b.__isset);
}

backup_request::backup_request(const backup_request& other4) {
  pid = other4.pid;
  policy = other4.policy;
  app_name = other4.app_name;
  backup_id = other4.backup_id;
  backup_path = other4.backup_path;
  __isset = other4.__isset;
}
backup_request& backup_request::operator=(const backup_request& other5) {
  pid = other5.pid;
  policy = other5.policy;
  app_name = other5.app_name;
  backup_id = other5.backup_id;
  backup_path = other5.backup_path;
  __isset = other5.__isset;
  return *this;
}
void backup_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backup_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "policy=" << to_string(policy);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "backup_id=" << to_string(backup_id);
  out << ", " << "backup_path="; (__isset.backup_path ? (out << to_string(backup_path)) : (out << "<null>"));
  out << ")";
}


backup_response::~backup_response() throw() {
}


void backup_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void backup_response::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void backup_response::__set_progress(const int32_t val) {
  this->progress = val;
}

void backup_response::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void backup_response::__set_backup_id(const int64_t val) {
  this->backup_id = val;
}

void backup_response::__set_checkpoint_total_size(const int64_t val) {
  this->checkpoint_total_size = val;
}

uint32_t backup_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->checkpoint_total_size);
          this->__isset.checkpoint_total_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backup_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backup_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->backup_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("checkpoint_total_size", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->checkpoint_total_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backup_response &a, backup_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.pid, b.pid);
  swap(a.progress, b.progress);
  swap(a.policy_name, b.policy_name);
  swap(a.backup_id, b.backup_id);
  swap(a.checkpoint_total_size, b.checkpoint_total_size);
  swap(a.__isset, b.__isset);
}

backup_response::backup_response(const backup_response& other6) {
  err = other6.err;
  pid = other6.pid;
  progress = other6.progress;
  policy_name = other6.policy_name;
  backup_id = other6.backup_id;
  checkpoint_total_size = other6.checkpoint_total_size;
  __isset = other6.__isset;
}
backup_response& backup_response::operator=(const backup_response& other7) {
  err = other7.err;
  pid = other7.pid;
  progress = other7.progress;
  policy_name = other7.policy_name;
  backup_id = other7.backup_id;
  checkpoint_total_size = other7.checkpoint_total_size;
  __isset = other7.__isset;
  return *this;
}
void backup_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backup_response(";
  out << "err=" << to_string(err);
  out << ", " << "pid=" << to_string(pid);
  out << ", " << "progress=" << to_string(progress);
  out << ", " << "policy_name=" << to_string(policy_name);
  out << ", " << "backup_id=" << to_string(backup_id);
  out << ", " << "checkpoint_total_size=" << to_string(checkpoint_total_size);
  out << ")";
}


backup_clear_request::~backup_clear_request() throw() {
}


void backup_clear_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void backup_clear_request::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

uint32_t backup_clear_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backup_clear_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backup_clear_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backup_clear_request &a, backup_clear_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.policy_name, b.policy_name);
  swap(a.__isset, b.__isset);
}

backup_clear_request::backup_clear_request(const backup_clear_request& other8) {
  pid = other8.pid;
  policy_name = other8.policy_name;
  __isset = other8.__isset;
}
backup_clear_request& backup_clear_request::operator=(const backup_clear_request& other9) {
  pid = other9.pid;
  policy_name = other9.policy_name;
  __isset = other9.__isset;
  return *this;
}
void backup_clear_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backup_clear_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "policy_name=" << to_string(policy_name);
  out << ")";
}


configuration_modify_backup_policy_request::~configuration_modify_backup_policy_request() throw() {
}


void configuration_modify_backup_policy_request::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void configuration_modify_backup_policy_request::__set_add_appids(const std::vector<int32_t> & val) {
  this->add_appids = val;
__isset.add_appids = true;
}

void configuration_modify_backup_policy_request::__set_removal_appids(const std::vector<int32_t> & val) {
  this->removal_appids = val;
__isset.removal_appids = true;
}

void configuration_modify_backup_policy_request::__set_new_backup_interval_sec(const int64_t val) {
  this->new_backup_interval_sec = val;
__isset.new_backup_interval_sec = true;
}

void configuration_modify_backup_policy_request::__set_backup_history_count_to_keep(const int32_t val) {
  this->backup_history_count_to_keep = val;
__isset.backup_history_count_to_keep = true;
}

void configuration_modify_backup_policy_request::__set_is_disable(const bool val) {
  this->is_disable = val;
__isset.is_disable = true;
}

void configuration_modify_backup_policy_request::__set_start_time(const std::string& val) {
  this->start_time = val;
__isset.start_time = true;
}

uint32_t configuration_modify_backup_policy_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->add_appids.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->add_appids.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readI32(this->add_appids[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.add_appids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->removal_appids.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->removal_appids.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readI32(this->removal_appids[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.removal_appids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->new_backup_interval_sec);
          this->__isset.new_backup_interval_sec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backup_history_count_to_keep);
          this->__isset.backup_history_count_to_keep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disable);
          this->__isset.is_disable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_modify_backup_policy_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_modify_backup_policy_request");

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.add_appids) {
    xfer += oprot->writeFieldBegin("add_appids", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->add_appids.size()));
      std::vector<int32_t> ::const_iterator _iter20;
      for (_iter20 = this->add_appids.begin(); _iter20 != this->add_appids.end(); ++_iter20)
      {
        xfer += oprot->writeI32((*_iter20));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.removal_appids) {
    xfer += oprot->writeFieldBegin("removal_appids", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->removal_appids.size()));
      std::vector<int32_t> ::const_iterator _iter21;
      for (_iter21 = this->removal_appids.begin(); _iter21 != this->removal_appids.end(); ++_iter21)
      {
        xfer += oprot->writeI32((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.new_backup_interval_sec) {
    xfer += oprot->writeFieldBegin("new_backup_interval_sec", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->new_backup_interval_sec);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_history_count_to_keep) {
    xfer += oprot->writeFieldBegin("backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->backup_history_count_to_keep);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disable) {
    xfer += oprot->writeFieldBegin("is_disable", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_disable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_time) {
    xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->start_time);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_modify_backup_policy_request &a, configuration_modify_backup_policy_request &b) {
  using ::std::swap;
  swap(a.policy_name, b.policy_name);
  swap(a.add_appids, b.add_appids);
  swap(a.removal_appids, b.removal_appids);
  swap(a.new_backup_interval_sec, b.new_backup_interval_sec);
  swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
  swap(a.is_disable, b.is_disable);
  swap(a.start_time, b.start_time);
  swap(a.__isset, b.__isset);
}

configuration_modify_backup_policy_request::configuration_modify_backup_policy_request(const configuration_modify_backup_policy_request& other22) {
  policy_name = other22.policy_name;
  add_appids = other22.add_appids;
  removal_appids = other22.removal_appids;
  new_backup_interval_sec = other22.new_backup_interval_sec;
  backup_history_count_to_keep = other22.backup_history_count_to_keep;
  is_disable = other22.is_disable;
  start_time = other22.start_time;
  __isset = other22.__isset;
}
configuration_modify_backup_policy_request& configuration_modify_backup_policy_request::operator=(const configuration_modify_backup_policy_request& other23) {
  policy_name = other23.policy_name;
  add_appids = other23.add_appids;
  removal_appids = other23.removal_appids;
  new_backup_interval_sec = other23.new_backup_interval_sec;
  backup_history_count_to_keep = other23.backup_history_count_to_keep;
  is_disable = other23.is_disable;
  start_time = other23.start_time;
  __isset = other23.__isset;
  return *this;
}
void configuration_modify_backup_policy_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_modify_backup_policy_request(";
  out << "policy_name=" << to_string(policy_name);
  out << ", " << "add_appids="; (__isset.add_appids ? (out << to_string(add_appids)) : (out << "<null>"));
  out << ", " << "removal_appids="; (__isset.removal_appids ? (out << to_string(removal_appids)) : (out << "<null>"));
  out << ", " << "new_backup_interval_sec="; (__isset.new_backup_interval_sec ? (out << to_string(new_backup_interval_sec)) : (out << "<null>"));
  out << ", " << "backup_history_count_to_keep="; (__isset.backup_history_count_to_keep ? (out << to_string(backup_history_count_to_keep)) : (out << "<null>"));
  out << ", " << "is_disable="; (__isset.is_disable ? (out << to_string(is_disable)) : (out << "<null>"));
  out << ", " << "start_time="; (__isset.start_time ? (out << to_string(start_time)) : (out << "<null>"));
  out << ")";
}


configuration_modify_backup_policy_response::~configuration_modify_backup_policy_response() throw() {
}


void configuration_modify_backup_policy_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_modify_backup_policy_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_modify_backup_policy_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_modify_backup_policy_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_modify_backup_policy_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_modify_backup_policy_response &a, configuration_modify_backup_policy_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_modify_backup_policy_response::configuration_modify_backup_policy_response(const configuration_modify_backup_policy_response& other24) {
  err = other24.err;
  hint_message = other24.hint_message;
  __isset = other24.__isset;
}
configuration_modify_backup_policy_response& configuration_modify_backup_policy_response::operator=(const configuration_modify_backup_policy_response& other25) {
  err = other25.err;
  hint_message = other25.hint_message;
  __isset = other25.__isset;
  return *this;
}
void configuration_modify_backup_policy_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_modify_backup_policy_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


configuration_add_backup_policy_request::~configuration_add_backup_policy_request() throw() {
}


void configuration_add_backup_policy_request::__set_backup_provider_type(const std::string& val) {
  this->backup_provider_type = val;
}

void configuration_add_backup_policy_request::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void configuration_add_backup_policy_request::__set_app_ids(const std::vector<int32_t> & val) {
  this->app_ids = val;
}

void configuration_add_backup_policy_request::__set_backup_interval_seconds(const int64_t val) {
  this->backup_interval_seconds = val;
}

void configuration_add_backup_policy_request::__set_backup_history_count_to_keep(const int32_t val) {
  this->backup_history_count_to_keep = val;
}

void configuration_add_backup_policy_request::__set_start_time(const std::string& val) {
  this->start_time = val;
}

uint32_t configuration_add_backup_policy_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_type);
          this->__isset.backup_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->app_ids.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->app_ids.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readI32(this->app_ids[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.app_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_interval_seconds);
          this->__isset.backup_interval_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backup_history_count_to_keep);
          this->__isset.backup_history_count_to_keep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_add_backup_policy_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_add_backup_policy_request");

  xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->backup_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->app_ids.size()));
    std::vector<int32_t> ::const_iterator _iter31;
    for (_iter31 = this->app_ids.begin(); _iter31 != this->app_ids.end(); ++_iter31)
    {
      xfer += oprot->writeI32((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_interval_seconds", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->backup_interval_seconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->backup_history_count_to_keep);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_add_backup_policy_request &a, configuration_add_backup_policy_request &b) {
  using ::std::swap;
  swap(a.backup_provider_type, b.backup_provider_type);
  swap(a.policy_name, b.policy_name);
  swap(a.app_ids, b.app_ids);
  swap(a.backup_interval_seconds, b.backup_interval_seconds);
  swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
  swap(a.start_time, b.start_time);
  swap(a.__isset, b.__isset);
}

configuration_add_backup_policy_request::configuration_add_backup_policy_request(const configuration_add_backup_policy_request& other32) {
  backup_provider_type = other32.backup_provider_type;
  policy_name = other32.policy_name;
  app_ids = other32.app_ids;
  backup_interval_seconds = other32.backup_interval_seconds;
  backup_history_count_to_keep = other32.backup_history_count_to_keep;
  start_time = other32.start_time;
  __isset = other32.__isset;
}
configuration_add_backup_policy_request& configuration_add_backup_policy_request::operator=(const configuration_add_backup_policy_request& other33) {
  backup_provider_type = other33.backup_provider_type;
  policy_name = other33.policy_name;
  app_ids = other33.app_ids;
  backup_interval_seconds = other33.backup_interval_seconds;
  backup_history_count_to_keep = other33.backup_history_count_to_keep;
  start_time = other33.start_time;
  __isset = other33.__isset;
  return *this;
}
void configuration_add_backup_policy_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_add_backup_policy_request(";
  out << "backup_provider_type=" << to_string(backup_provider_type);
  out << ", " << "policy_name=" << to_string(policy_name);
  out << ", " << "app_ids=" << to_string(app_ids);
  out << ", " << "backup_interval_seconds=" << to_string(backup_interval_seconds);
  out << ", " << "backup_history_count_to_keep=" << to_string(backup_history_count_to_keep);
  out << ", " << "start_time=" << to_string(start_time);
  out << ")";
}


configuration_add_backup_policy_response::~configuration_add_backup_policy_response() throw() {
}


void configuration_add_backup_policy_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_add_backup_policy_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

uint32_t configuration_add_backup_policy_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_add_backup_policy_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_add_backup_policy_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_add_backup_policy_response &a, configuration_add_backup_policy_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.__isset, b.__isset);
}

configuration_add_backup_policy_response::configuration_add_backup_policy_response(const configuration_add_backup_policy_response& other34) {
  err = other34.err;
  hint_message = other34.hint_message;
  __isset = other34.__isset;
}
configuration_add_backup_policy_response& configuration_add_backup_policy_response::operator=(const configuration_add_backup_policy_response& other35) {
  err = other35.err;
  hint_message = other35.hint_message;
  __isset = other35.__isset;
  return *this;
}
void configuration_add_backup_policy_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_add_backup_policy_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ")";
}


policy_entry::~policy_entry() throw() {
}


void policy_entry::__set_policy_name(const std::string& val) {
  this->policy_name = val;
}

void policy_entry::__set_backup_provider_type(const std::string& val) {
  this->backup_provider_type = val;
}

void policy_entry::__set_backup_interval_seconds(const std::string& val) {
  this->backup_interval_seconds = val;
}

void policy_entry::__set_app_ids(const std::set<int32_t> & val) {
  this->app_ids = val;
}

void policy_entry::__set_backup_history_count_to_keep(const int32_t val) {
  this->backup_history_count_to_keep = val;
}

void policy_entry::__set_start_time(const std::string& val) {
  this->start_time = val;
}

void policy_entry::__set_is_disable(const bool val) {
  this->is_disable = val;
}

uint32_t policy_entry::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policy_name);
          this->__isset.policy_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_type);
          this->__isset.backup_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_interval_seconds);
          this->__isset.backup_interval_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->app_ids.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readSetBegin(_etype39, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              int32_t _elem41;
              xfer += iprot->readI32(_elem41);
              this->app_ids.insert(_elem41);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.app_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backup_history_count_to_keep);
          this->__isset.backup_history_count_to_keep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disable);
          this->__isset.is_disable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t policy_entry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("policy_entry");

  xfer += oprot->writeFieldBegin("policy_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->policy_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->backup_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_interval_seconds", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->backup_interval_seconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->app_ids.size()));
    std::set<int32_t> ::const_iterator _iter42;
    for (_iter42 = this->app_ids.begin(); _iter42 != this->app_ids.end(); ++_iter42)
    {
      xfer += oprot->writeI32((*_iter42));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_history_count_to_keep", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->backup_history_count_to_keep);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_disable", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_disable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(policy_entry &a, policy_entry &b) {
  using ::std::swap;
  swap(a.policy_name, b.policy_name);
  swap(a.backup_provider_type, b.backup_provider_type);
  swap(a.backup_interval_seconds, b.backup_interval_seconds);
  swap(a.app_ids, b.app_ids);
  swap(a.backup_history_count_to_keep, b.backup_history_count_to_keep);
  swap(a.start_time, b.start_time);
  swap(a.is_disable, b.is_disable);
  swap(a.__isset, b.__isset);
}

policy_entry::policy_entry(const policy_entry& other43) {
  policy_name = other43.policy_name;
  backup_provider_type = other43.backup_provider_type;
  backup_interval_seconds = other43.backup_interval_seconds;
  app_ids = other43.app_ids;
  backup_history_count_to_keep = other43.backup_history_count_to_keep;
  start_time = other43.start_time;
  is_disable = other43.is_disable;
  __isset = other43.__isset;
}
policy_entry& policy_entry::operator=(const policy_entry& other44) {
  policy_name = other44.policy_name;
  backup_provider_type = other44.backup_provider_type;
  backup_interval_seconds = other44.backup_interval_seconds;
  app_ids = other44.app_ids;
  backup_history_count_to_keep = other44.backup_history_count_to_keep;
  start_time = other44.start_time;
  is_disable = other44.is_disable;
  __isset = other44.__isset;
  return *this;
}
void policy_entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "policy_entry(";
  out << "policy_name=" << to_string(policy_name);
  out << ", " << "backup_provider_type=" << to_string(backup_provider_type);
  out << ", " << "backup_interval_seconds=" << to_string(backup_interval_seconds);
  out << ", " << "app_ids=" << to_string(app_ids);
  out << ", " << "backup_history_count_to_keep=" << to_string(backup_history_count_to_keep);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "is_disable=" << to_string(is_disable);
  out << ")";
}


backup_entry::~backup_entry() throw() {
}


void backup_entry::__set_backup_id(const int64_t val) {
  this->backup_id = val;
}

void backup_entry::__set_start_time_ms(const int64_t val) {
  this->start_time_ms = val;
}

void backup_entry::__set_end_time_ms(const int64_t val) {
  this->end_time_ms = val;
}

void backup_entry::__set_app_ids(const std::set<int32_t> & val) {
  this->app_ids = val;
}

uint32_t backup_entry::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time_ms);
          this->__isset.start_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time_ms);
          this->__isset.end_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->app_ids.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readSetBegin(_etype48, _size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              int32_t _elem50;
              xfer += iprot->readI32(_elem50);
              this->app_ids.insert(_elem50);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.app_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backup_entry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backup_entry");

  xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->backup_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->start_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->end_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_ids", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->app_ids.size()));
    std::set<int32_t> ::const_iterator _iter51;
    for (_iter51 = this->app_ids.begin(); _iter51 != this->app_ids.end(); ++_iter51)
    {
      xfer += oprot->writeI32((*_iter51));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backup_entry &a, backup_entry &b) {
  using ::std::swap;
  swap(a.backup_id, b.backup_id);
  swap(a.start_time_ms, b.start_time_ms);
  swap(a.end_time_ms, b.end_time_ms);
  swap(a.app_ids, b.app_ids);
  swap(a.__isset, b.__isset);
}

backup_entry::backup_entry(const backup_entry& other52) {
  backup_id = other52.backup_id;
  start_time_ms = other52.start_time_ms;
  end_time_ms = other52.end_time_ms;
  app_ids = other52.app_ids;
  __isset = other52.__isset;
}
backup_entry& backup_entry::operator=(const backup_entry& other53) {
  backup_id = other53.backup_id;
  start_time_ms = other53.start_time_ms;
  end_time_ms = other53.end_time_ms;
  app_ids = other53.app_ids;
  __isset = other53.__isset;
  return *this;
}
void backup_entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backup_entry(";
  out << "backup_id=" << to_string(backup_id);
  out << ", " << "start_time_ms=" << to_string(start_time_ms);
  out << ", " << "end_time_ms=" << to_string(end_time_ms);
  out << ", " << "app_ids=" << to_string(app_ids);
  out << ")";
}


configuration_query_backup_policy_request::~configuration_query_backup_policy_request() throw() {
}


void configuration_query_backup_policy_request::__set_policy_names(const std::vector<std::string> & val) {
  this->policy_names = val;
}

void configuration_query_backup_policy_request::__set_backup_info_count(const int32_t val) {
  this->backup_info_count = val;
}

uint32_t configuration_query_backup_policy_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->policy_names.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->policy_names.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += iprot->readString(this->policy_names[_i58]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.policy_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backup_info_count);
          this->__isset.backup_info_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_backup_policy_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_backup_policy_request");

  xfer += oprot->writeFieldBegin("policy_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->policy_names.size()));
    std::vector<std::string> ::const_iterator _iter59;
    for (_iter59 = this->policy_names.begin(); _iter59 != this->policy_names.end(); ++_iter59)
    {
      xfer += oprot->writeString((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_info_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->backup_info_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_backup_policy_request &a, configuration_query_backup_policy_request &b) {
  using ::std::swap;
  swap(a.policy_names, b.policy_names);
  swap(a.backup_info_count, b.backup_info_count);
  swap(a.__isset, b.__isset);
}

configuration_query_backup_policy_request::configuration_query_backup_policy_request(const configuration_query_backup_policy_request& other60) {
  policy_names = other60.policy_names;
  backup_info_count = other60.backup_info_count;
  __isset = other60.__isset;
}
configuration_query_backup_policy_request& configuration_query_backup_policy_request::operator=(const configuration_query_backup_policy_request& other61) {
  policy_names = other61.policy_names;
  backup_info_count = other61.backup_info_count;
  __isset = other61.__isset;
  return *this;
}
void configuration_query_backup_policy_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_backup_policy_request(";
  out << "policy_names=" << to_string(policy_names);
  out << ", " << "backup_info_count=" << to_string(backup_info_count);
  out << ")";
}


configuration_query_backup_policy_response::~configuration_query_backup_policy_response() throw() {
}


void configuration_query_backup_policy_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_backup_policy_response::__set_policys(const std::vector<policy_entry> & val) {
  this->policys = val;
}

void configuration_query_backup_policy_response::__set_backup_infos(const std::vector<std::vector<backup_entry> > & val) {
  this->backup_infos = val;
}

void configuration_query_backup_policy_response::__set_hint_msg(const std::string& val) {
  this->hint_msg = val;
__isset.hint_msg = true;
}

uint32_t configuration_query_backup_policy_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->policys.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->policys.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->policys[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.policys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->backup_infos.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->backup_infos.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              {
                this->backup_infos[_i71].clear();
                uint32_t _size72;
                ::apache::thrift::protocol::TType _etype75;
                xfer += iprot->readListBegin(_etype75, _size72);
                this->backup_infos[_i71].resize(_size72);
                uint32_t _i76;
                for (_i76 = 0; _i76 < _size72; ++_i76)
                {
                  xfer += this->backup_infos[_i71][_i76].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.backup_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_msg);
          this->__isset.hint_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_backup_policy_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_backup_policy_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policys", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->policys.size()));
    std::vector<policy_entry> ::const_iterator _iter77;
    for (_iter77 = this->policys.begin(); _iter77 != this->policys.end(); ++_iter77)
    {
      xfer += (*_iter77).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_infos", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->backup_infos.size()));
    std::vector<std::vector<backup_entry> > ::const_iterator _iter78;
    for (_iter78 = this->backup_infos.begin(); _iter78 != this->backup_infos.end(); ++_iter78)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter78).size()));
        std::vector<backup_entry> ::const_iterator _iter79;
        for (_iter79 = (*_iter78).begin(); _iter79 != (*_iter78).end(); ++_iter79)
        {
          xfer += (*_iter79).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hint_msg) {
    xfer += oprot->writeFieldBegin("hint_msg", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->hint_msg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_backup_policy_response &a, configuration_query_backup_policy_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.policys, b.policys);
  swap(a.backup_infos, b.backup_infos);
  swap(a.hint_msg, b.hint_msg);
  swap(a.__isset, b.__isset);
}

configuration_query_backup_policy_response::configuration_query_backup_policy_response(const configuration_query_backup_policy_response& other80) {
  err = other80.err;
  policys = other80.policys;
  backup_infos = other80.backup_infos;
  hint_msg = other80.hint_msg;
  __isset = other80.__isset;
}
configuration_query_backup_policy_response& configuration_query_backup_policy_response::operator=(const configuration_query_backup_policy_response& other81) {
  err = other81.err;
  policys = other81.policys;
  backup_infos = other81.backup_infos;
  hint_msg = other81.hint_msg;
  __isset = other81.__isset;
  return *this;
}
void configuration_query_backup_policy_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_backup_policy_response(";
  out << "err=" << to_string(err);
  out << ", " << "policys=" << to_string(policys);
  out << ", " << "backup_infos=" << to_string(backup_infos);
  out << ", " << "hint_msg="; (__isset.hint_msg ? (out << to_string(hint_msg)) : (out << "<null>"));
  out << ")";
}


configuration_report_restore_status_request::~configuration_report_restore_status_request() throw() {
}


void configuration_report_restore_status_request::__set_pid(const  ::dsn::gpid& val) {
  this->pid = val;
}

void configuration_report_restore_status_request::__set_restore_status(const  ::dsn::error_code& val) {
  this->restore_status = val;
}

void configuration_report_restore_status_request::__set_progress(const int32_t val) {
  this->progress = val;
}

void configuration_report_restore_status_request::__set_reason(const std::string& val) {
  this->reason = val;
__isset.reason = true;
}

uint32_t configuration_report_restore_status_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pid.read(iprot);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->restore_status.read(iprot);
          this->__isset.restore_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_report_restore_status_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_report_restore_status_request");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("restore_status", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->restore_status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->progress);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.reason) {
    xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->reason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_report_restore_status_request &a, configuration_report_restore_status_request &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.restore_status, b.restore_status);
  swap(a.progress, b.progress);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

configuration_report_restore_status_request::configuration_report_restore_status_request(const configuration_report_restore_status_request& other82) {
  pid = other82.pid;
  restore_status = other82.restore_status;
  progress = other82.progress;
  reason = other82.reason;
  __isset = other82.__isset;
}
configuration_report_restore_status_request& configuration_report_restore_status_request::operator=(const configuration_report_restore_status_request& other83) {
  pid = other83.pid;
  restore_status = other83.restore_status;
  progress = other83.progress;
  reason = other83.reason;
  __isset = other83.__isset;
  return *this;
}
void configuration_report_restore_status_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_report_restore_status_request(";
  out << "pid=" << to_string(pid);
  out << ", " << "restore_status=" << to_string(restore_status);
  out << ", " << "progress=" << to_string(progress);
  out << ", " << "reason="; (__isset.reason ? (out << to_string(reason)) : (out << "<null>"));
  out << ")";
}


configuration_report_restore_status_response::~configuration_report_restore_status_response() throw() {
}


void configuration_report_restore_status_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_report_restore_status_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_report_restore_status_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_report_restore_status_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_report_restore_status_response &a, configuration_report_restore_status_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_report_restore_status_response::configuration_report_restore_status_response(const configuration_report_restore_status_response& other84) {
  err = other84.err;
  __isset = other84.__isset;
}
configuration_report_restore_status_response& configuration_report_restore_status_response::operator=(const configuration_report_restore_status_response& other85) {
  err = other85.err;
  __isset = other85.__isset;
  return *this;
}
void configuration_report_restore_status_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_report_restore_status_response(";
  out << "err=" << to_string(err);
  out << ")";
}


configuration_query_restore_request::~configuration_query_restore_request() throw() {
}


void configuration_query_restore_request::__set_restore_app_id(const int32_t val) {
  this->restore_app_id = val;
}

uint32_t configuration_query_restore_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->restore_app_id);
          this->__isset.restore_app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_restore_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_restore_request");

  xfer += oprot->writeFieldBegin("restore_app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->restore_app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_restore_request &a, configuration_query_restore_request &b) {
  using ::std::swap;
  swap(a.restore_app_id, b.restore_app_id);
  swap(a.__isset, b.__isset);
}

configuration_query_restore_request::configuration_query_restore_request(const configuration_query_restore_request& other86) {
  restore_app_id = other86.restore_app_id;
  __isset = other86.__isset;
}
configuration_query_restore_request& configuration_query_restore_request::operator=(const configuration_query_restore_request& other87) {
  restore_app_id = other87.restore_app_id;
  __isset = other87.__isset;
  return *this;
}
void configuration_query_restore_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_restore_request(";
  out << "restore_app_id=" << to_string(restore_app_id);
  out << ")";
}


configuration_query_restore_response::~configuration_query_restore_response() throw() {
}


void configuration_query_restore_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_restore_response::__set_restore_status(const std::vector< ::dsn::error_code> & val) {
  this->restore_status = val;
}

void configuration_query_restore_response::__set_restore_progress(const std::vector<int32_t> & val) {
  this->restore_progress = val;
}

uint32_t configuration_query_restore_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->restore_status.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->restore_status.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->restore_status[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.restore_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->restore_progress.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->restore_progress.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readI32(this->restore_progress[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.restore_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_restore_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_restore_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("restore_status", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->restore_status.size()));
    std::vector< ::dsn::error_code> ::const_iterator _iter98;
    for (_iter98 = this->restore_status.begin(); _iter98 != this->restore_status.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("restore_progress", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->restore_progress.size()));
    std::vector<int32_t> ::const_iterator _iter99;
    for (_iter99 = this->restore_progress.begin(); _iter99 != this->restore_progress.end(); ++_iter99)
    {
      xfer += oprot->writeI32((*_iter99));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_restore_response &a, configuration_query_restore_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.restore_status, b.restore_status);
  swap(a.restore_progress, b.restore_progress);
  swap(a.__isset, b.__isset);
}

configuration_query_restore_response::configuration_query_restore_response(const configuration_query_restore_response& other100) {
  err = other100.err;
  restore_status = other100.restore_status;
  restore_progress = other100.restore_progress;
  __isset = other100.__isset;
}
configuration_query_restore_response& configuration_query_restore_response::operator=(const configuration_query_restore_response& other101) {
  err = other101.err;
  restore_status = other101.restore_status;
  restore_progress = other101.restore_progress;
  __isset = other101.__isset;
  return *this;
}
void configuration_query_restore_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_restore_response(";
  out << "err=" << to_string(err);
  out << ", " << "restore_status=" << to_string(restore_status);
  out << ", " << "restore_progress=" << to_string(restore_progress);
  out << ")";
}


start_backup_app_request::~start_backup_app_request() throw() {
}


void start_backup_app_request::__set_backup_provider_type(const std::string& val) {
  this->backup_provider_type = val;
}

void start_backup_app_request::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void start_backup_app_request::__set_backup_path(const std::string& val) {
  this->backup_path = val;
__isset.backup_path = true;
}

uint32_t start_backup_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_type);
          this->__isset.backup_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_path);
          this->__isset.backup_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_backup_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_backup_app_request");

  xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->backup_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.backup_path) {
    xfer += oprot->writeFieldBegin("backup_path", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->backup_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_backup_app_request &a, start_backup_app_request &b) {
  using ::std::swap;
  swap(a.backup_provider_type, b.backup_provider_type);
  swap(a.app_id, b.app_id);
  swap(a.backup_path, b.backup_path);
  swap(a.__isset, b.__isset);
}

start_backup_app_request::start_backup_app_request(const start_backup_app_request& other102) {
  backup_provider_type = other102.backup_provider_type;
  app_id = other102.app_id;
  backup_path = other102.backup_path;
  __isset = other102.__isset;
}
start_backup_app_request& start_backup_app_request::operator=(const start_backup_app_request& other103) {
  backup_provider_type = other103.backup_provider_type;
  app_id = other103.app_id;
  backup_path = other103.backup_path;
  __isset = other103.__isset;
  return *this;
}
void start_backup_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_backup_app_request(";
  out << "backup_provider_type=" << to_string(backup_provider_type);
  out << ", " << "app_id=" << to_string(app_id);
  out << ", " << "backup_path="; (__isset.backup_path ? (out << to_string(backup_path)) : (out << "<null>"));
  out << ")";
}


start_backup_app_response::~start_backup_app_response() throw() {
}


void start_backup_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void start_backup_app_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

void start_backup_app_response::__set_backup_id(const int64_t val) {
  this->backup_id = val;
__isset.backup_id = true;
}

uint32_t start_backup_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t start_backup_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("start_backup_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.backup_id) {
    xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->backup_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(start_backup_app_response &a, start_backup_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.backup_id, b.backup_id);
  swap(a.__isset, b.__isset);
}

start_backup_app_response::start_backup_app_response(const start_backup_app_response& other104) {
  err = other104.err;
  hint_message = other104.hint_message;
  backup_id = other104.backup_id;
  __isset = other104.__isset;
}
start_backup_app_response& start_backup_app_response::operator=(const start_backup_app_response& other105) {
  err = other105.err;
  hint_message = other105.hint_message;
  backup_id = other105.backup_id;
  __isset = other105.__isset;
  return *this;
}
void start_backup_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "start_backup_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ", " << "backup_id="; (__isset.backup_id ? (out << to_string(backup_id)) : (out << "<null>"));
  out << ")";
}


backup_item::~backup_item() throw() {
}


void backup_item::__set_backup_id(const int64_t val) {
  this->backup_id = val;
}

void backup_item::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void backup_item::__set_backup_provider_type(const std::string& val) {
  this->backup_provider_type = val;
}

void backup_item::__set_backup_path(const std::string& val) {
  this->backup_path = val;
}

void backup_item::__set_start_time_ms(const int64_t val) {
  this->start_time_ms = val;
}

void backup_item::__set_end_time_ms(const int64_t val) {
  this->end_time_ms = val;
}

void backup_item::__set_is_backup_failed(const bool val) {
  this->is_backup_failed = val;
}

uint32_t backup_item::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_provider_type);
          this->__isset.backup_provider_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_path);
          this->__isset.backup_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time_ms);
          this->__isset.start_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time_ms);
          this->__isset.end_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_backup_failed);
          this->__isset.is_backup_failed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backup_item::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backup_item");

  xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->backup_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_provider_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->backup_provider_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backup_path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->backup_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->start_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_time_ms", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->end_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_backup_failed", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_backup_failed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backup_item &a, backup_item &b) {
  using ::std::swap;
  swap(a.backup_id, b.backup_id);
  swap(a.app_name, b.app_name);
  swap(a.backup_provider_type, b.backup_provider_type);
  swap(a.backup_path, b.backup_path);
  swap(a.start_time_ms, b.start_time_ms);
  swap(a.end_time_ms, b.end_time_ms);
  swap(a.is_backup_failed, b.is_backup_failed);
  swap(a.__isset, b.__isset);
}

backup_item::backup_item(const backup_item& other106) {
  backup_id = other106.backup_id;
  app_name = other106.app_name;
  backup_provider_type = other106.backup_provider_type;
  backup_path = other106.backup_path;
  start_time_ms = other106.start_time_ms;
  end_time_ms = other106.end_time_ms;
  is_backup_failed = other106.is_backup_failed;
  __isset = other106.__isset;
}
backup_item& backup_item::operator=(const backup_item& other107) {
  backup_id = other107.backup_id;
  app_name = other107.app_name;
  backup_provider_type = other107.backup_provider_type;
  backup_path = other107.backup_path;
  start_time_ms = other107.start_time_ms;
  end_time_ms = other107.end_time_ms;
  is_backup_failed = other107.is_backup_failed;
  __isset = other107.__isset;
  return *this;
}
void backup_item::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backup_item(";
  out << "backup_id=" << to_string(backup_id);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "backup_provider_type=" << to_string(backup_provider_type);
  out << ", " << "backup_path=" << to_string(backup_path);
  out << ", " << "start_time_ms=" << to_string(start_time_ms);
  out << ", " << "end_time_ms=" << to_string(end_time_ms);
  out << ", " << "is_backup_failed=" << to_string(is_backup_failed);
  out << ")";
}


query_backup_status_request::~query_backup_status_request() throw() {
}


void query_backup_status_request::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void query_backup_status_request::__set_backup_id(const int64_t val) {
  this->backup_id = val;
__isset.backup_id = true;
}

uint32_t query_backup_status_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backup_id);
          this->__isset.backup_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_backup_status_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_backup_status_request");

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.backup_id) {
    xfer += oprot->writeFieldBegin("backup_id", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->backup_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_backup_status_request &a, query_backup_status_request &b) {
  using ::std::swap;
  swap(a.app_id, b.app_id);
  swap(a.backup_id, b.backup_id);
  swap(a.__isset, b.__isset);
}

query_backup_status_request::query_backup_status_request(const query_backup_status_request& other108) {
  app_id = other108.app_id;
  backup_id = other108.backup_id;
  __isset = other108.__isset;
}
query_backup_status_request& query_backup_status_request::operator=(const query_backup_status_request& other109) {
  app_id = other109.app_id;
  backup_id = other109.backup_id;
  __isset = other109.__isset;
  return *this;
}
void query_backup_status_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_backup_status_request(";
  out << "app_id=" << to_string(app_id);
  out << ", " << "backup_id="; (__isset.backup_id ? (out << to_string(backup_id)) : (out << "<null>"));
  out << ")";
}


query_backup_status_response::~query_backup_status_response() throw() {
}


void query_backup_status_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_backup_status_response::__set_hint_message(const std::string& val) {
  this->hint_message = val;
}

void query_backup_status_response::__set_backup_items(const std::vector<backup_item> & val) {
  this->backup_items = val;
__isset.backup_items = true;
}

uint32_t query_backup_status_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hint_message);
          this->__isset.hint_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->backup_items.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->backup_items.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += this->backup_items[_i114].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.backup_items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_backup_status_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_backup_status_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hint_message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hint_message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.backup_items) {
    xfer += oprot->writeFieldBegin("backup_items", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->backup_items.size()));
      std::vector<backup_item> ::const_iterator _iter115;
      for (_iter115 = this->backup_items.begin(); _iter115 != this->backup_items.end(); ++_iter115)
      {
        xfer += (*_iter115).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_backup_status_response &a, query_backup_status_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.hint_message, b.hint_message);
  swap(a.backup_items, b.backup_items);
  swap(a.__isset, b.__isset);
}

query_backup_status_response::query_backup_status_response(const query_backup_status_response& other116) {
  err = other116.err;
  hint_message = other116.hint_message;
  backup_items = other116.backup_items;
  __isset = other116.__isset;
}
query_backup_status_response& query_backup_status_response::operator=(const query_backup_status_response& other117) {
  err = other117.err;
  hint_message = other117.hint_message;
  backup_items = other117.backup_items;
  __isset = other117.__isset;
  return *this;
}
void query_backup_status_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_backup_status_response(";
  out << "err=" << to_string(err);
  out << ", " << "hint_message=" << to_string(hint_message);
  out << ", " << "backup_items="; (__isset.backup_items ? (out << to_string(backup_items)) : (out << "<null>"));
  out << ")";
}

}} // namespace
